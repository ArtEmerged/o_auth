
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>grpc_server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ArtEmerged/o_auth-server/cmd/grpc_server/main.go (0.0%)</option>
				
				<option value="file1">github.com/ArtEmerged/o_auth-server/internal/adapter/user.go (100.0%)</option>
				
				<option value="file2">github.com/ArtEmerged/o_auth-server/internal/api/grpc/user/create.go (100.0%)</option>
				
				<option value="file3">github.com/ArtEmerged/o_auth-server/internal/api/grpc/user/delete.go (100.0%)</option>
				
				<option value="file4">github.com/ArtEmerged/o_auth-server/internal/api/grpc/user/get.go (87.5%)</option>
				
				<option value="file5">github.com/ArtEmerged/o_auth-server/internal/api/grpc/user/service.go (100.0%)</option>
				
				<option value="file6">github.com/ArtEmerged/o_auth-server/internal/api/grpc/user/update.go (100.0%)</option>
				
				<option value="file7">github.com/ArtEmerged/o_auth-server/internal/app/app.go (0.0%)</option>
				
				<option value="file8">github.com/ArtEmerged/o_auth-server/internal/app/service_provide.go (0.0%)</option>
				
				<option value="file9">github.com/ArtEmerged/o_auth-server/internal/closer/closer.go (0.0%)</option>
				
				<option value="file10">github.com/ArtEmerged/o_auth-server/internal/config/config.go (0.0%)</option>
				
				<option value="file11">github.com/ArtEmerged/o_auth-server/internal/model/user.go (100.0%)</option>
				
				<option value="file12">github.com/ArtEmerged/o_auth-server/internal/repository/mocks/user_repo_minimock.go (32.0%)</option>
				
				<option value="file13">github.com/ArtEmerged/o_auth-server/internal/repository/user/adapter/user.go (0.0%)</option>
				
				<option value="file14">github.com/ArtEmerged/o_auth-server/internal/repository/user/create.go (0.0%)</option>
				
				<option value="file15">github.com/ArtEmerged/o_auth-server/internal/repository/user/delete.go (0.0%)</option>
				
				<option value="file16">github.com/ArtEmerged/o_auth-server/internal/repository/user/get.go (0.0%)</option>
				
				<option value="file17">github.com/ArtEmerged/o_auth-server/internal/repository/user/repository.go (0.0%)</option>
				
				<option value="file18">github.com/ArtEmerged/o_auth-server/internal/repository/user/update.go (0.0%)</option>
				
				<option value="file19">github.com/ArtEmerged/o_auth-server/internal/service/mocks/user_service_minimock.go (32.0%)</option>
				
				<option value="file20">github.com/ArtEmerged/o_auth-server/internal/service/user/create.go (0.0%)</option>
				
				<option value="file21">github.com/ArtEmerged/o_auth-server/internal/service/user/dalete.go (0.0%)</option>
				
				<option value="file22">github.com/ArtEmerged/o_auth-server/internal/service/user/get.go (0.0%)</option>
				
				<option value="file23">github.com/ArtEmerged/o_auth-server/internal/service/user/helpers.go (100.0%)</option>
				
				<option value="file24">github.com/ArtEmerged/o_auth-server/internal/service/user/service.go (0.0%)</option>
				
				<option value="file25">github.com/ArtEmerged/o_auth-server/internal/service/user/update.go (0.0%)</option>
				
				<option value="file26">github.com/ArtEmerged/o_auth-server/pkg/auth_v1/auth.pb.go (12.7%)</option>
				
				<option value="file27">github.com/ArtEmerged/o_auth-server/pkg/auth_v1/auth_grpc.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"

        "github.com/ArtEmerged/o_auth-server/internal/app"
)

func main() <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        a, err := app.New(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to init app: %v", err)
                return
        }</span>

        <span class="cov0" title="0">err = a.Run()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to run app: %v", err)
        }</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package adapter

import (
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/ArtEmerged/o_auth-server/internal/model"
        desc "github.com/ArtEmerged/o_auth-server/pkg/auth_v1"
)

// CreateUserRequestToLocal adapts the CreateUserRequest proto to the local model.
func CreateUserRequestToLocal(in *desc.CreateUserRequest) *model.CreateUserRequest <span class="cov8" title="1">{
        return &amp;model.CreateUserRequest{
                Name:            in.GetName(),
                Email:           in.GetEmail(),
                Password:        in.GetPassword(),
                PasswordConfirm: in.GetPasswordConfirm(),
                Role:            model.Role(in.Role),
        }
}</span>

// UpdateUserRequestToLocal adapts the UpdateUserRequest proto to the local model.
func UpdateUserRequestToLocal(in *desc.UpdateUserRequest) *model.UpdateUserRequest <span class="cov8" title="1">{
        return &amp;model.UpdateUserRequest{
                ID:   in.GetId(),
                Name: in.GetName(),
                Role: model.Role(in.Role),
        }
}</span>

// UserInfoToProto adapts the local model to the proto model.
func UserInfoToProto(in *model.UserInfo) *desc.UserInfo <span class="cov8" title="1">{
        out := &amp;desc.UserInfo{
                Id:    in.ID,
                Name:  in.Name,
                Email: in.Email,
                Role:  desc.Role(in.Role),
        }

        out.Timestamp = &amp;desc.UserInfo_CreatedAt{CreatedAt: timestamppb.New(in.CreatedAt)}

        if in.UpdatedAt != nil </span><span class="cov8" title="1">{
                out.Timestamp = &amp;desc.UserInfo_UpdatedAt{UpdatedAt: timestamppb.New(*in.UpdatedAt)}
        }</span>

        <span class="cov8" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package user

import (
        "context"
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/ArtEmerged/o_auth-server/internal/adapter"
        "github.com/ArtEmerged/o_auth-server/internal/model"
        desc "github.com/ArtEmerged/o_auth-server/pkg/auth_v1"
)

// CreateUser handles the gRPC request to create a new user.
// It validates the input, creates the user via the service, and returns the user ID.
func (s *Implementation) CreateUser(ctx context.Context, in *desc.CreateUserRequest) (*desc.CreateUserResponse, error) <span class="cov8" title="1">{
        id, err := s.userService.CreateUser(ctx, adapter.CreateUserRequestToLocal(in))
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, model.ErrAlreadyExists) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.AlreadyExists, err.Error())
                }</span>
                <span class="cov8" title="1">if errors.Is(err, model.ErrInvalidArgument) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.InvalidArgument, err.Error())
                }</span>

                <span class="cov8" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }

        <span class="cov8" title="1">return &amp;desc.CreateUserResponse{Id: id}, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package user

import (
        "context"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        desc "github.com/ArtEmerged/o_auth-server/pkg/auth_v1"
)

// DeleteUser handles the gRPC request to delete a user by ID.
// It validates the input, deletes the user via the service, and returns an empty response.
func (s *Implementation) DeleteUser(ctx context.Context, in *desc.DeleteUserRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        if in.GetId() &lt; 1 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "negative id")
        }</span>

        <span class="cov8" title="1">err := s.userService.DeleteUser(ctx, in.GetId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package user

import (
        "context"
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/ArtEmerged/o_auth-server/internal/adapter"
        "github.com/ArtEmerged/o_auth-server/internal/model"
        desc "github.com/ArtEmerged/o_auth-server/pkg/auth_v1"
)

// GetUser handles the gRPC request to retrieve a user by ID.
// It validates the input, retrieves the user via the service, and returns the user information.
func (s *Implementation) GetUser(ctx context.Context, in *desc.GetUserRequest) (*desc.GetUserResponse, error) <span class="cov8" title="1">{
        if in.GetId() &lt; 1 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "negative id")
        }</span>

        <span class="cov8" title="1">userInfo, err := s.userService.GetUser(ctx, in.GetId())
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, model.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.NotFound, err.Error())
                }</span>
                <span class="cov8" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }

        <span class="cov8" title="1">return &amp;desc.GetUserResponse{UserInfo: adapter.UserInfoToProto(userInfo)}, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package user

import (
        "github.com/ArtEmerged/o_auth-server/internal/service"
        desc "github.com/ArtEmerged/o_auth-server/pkg/auth_v1"
)

var _ desc.UserV1Server = (*Implementation)(nil)

// Implementation implements user gRPC interface.
type Implementation struct {
        desc.UnimplementedUserV1Server

        userService service.UserService
}

// NewImplementation registers the user service on the gRPC server.
// s - pointer to the gRPC server
// service - the user service interface to be registered
func NewImplementation(userService service.UserService) *Implementation <span class="cov8" title="1">{
        return &amp;Implementation{userService: userService}
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package user

import (
        "context"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/ArtEmerged/o_auth-server/internal/adapter"
        desc "github.com/ArtEmerged/o_auth-server/pkg/auth_v1"
)

// UpdateUser handles the gRPC request to update an existing user.
// It validates the input, updates the user via the service, and returns an empty response.
func (s *Implementation) UpdateUser(ctx context.Context, in *desc.UpdateUserRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        if in.GetId() &lt; 1 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "negative id")
        }</span>

        <span class="cov8" title="1">err := s.userService.UpdateUser(ctx, adapter.UpdateUserRequestToLocal(in))
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "context"
        "log"
        "net"

        "github.com/ArtEmerged/o_auth-server/internal/closer"

        desc "github.com/ArtEmerged/o_auth-server/pkg/auth_v1"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/reflection"
)

// App represents application
type App struct {
        grpcServer *grpc.Server

        serviceProvider *serviceProvider
}

// New creates new app instance
func New(ctx context.Context) (*App, error) <span class="cov0" title="0">{
        a := &amp;App{}

        err := a.initDeps(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return a, nil</span>
}

// Run starts application
func (a *App) Run() error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                closer.CloseAll()
                closer.Wite()
        }</span>()

        <span class="cov0" title="0">return a.runGRPCServer()</span>
}

func (a *App) initDeps(ctx context.Context) error <span class="cov0" title="0">{
        inits := []func(context.Context) error{
                a.initServiceProvider,
                a.initGRPCServer,
        }

        for _, f := range inits </span><span class="cov0" title="0">{
                err := f(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (a *App) initServiceProvider(_ context.Context) error <span class="cov0" title="0">{
        a.serviceProvider = newServiceProvider()

        return nil
}</span>

func (a *App) initGRPCServer(ctx context.Context) error <span class="cov0" title="0">{
        a.grpcServer = grpc.NewServer(grpc.Creds(insecure.NewCredentials()))

        reflection.Register(a.grpcServer)

        desc.RegisterUserV1Server(a.grpcServer, a.serviceProvider.UserImplementation(ctx))

        return nil
}</span>

func (a *App) runGRPCServer() error <span class="cov0" title="0">{
        log.Printf("GRPC server is running on %s", a.serviceProvider.GlobalConfig().ServerAddress())

        list, err := net.Listen("tcp", a.serviceProvider.GlobalConfig().ServerAddress())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = a.grpcServer.Serve(list)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package app

import (
        "context"
        "log"

        "github.com/ArtEmerged/library/client/cache"
        "github.com/ArtEmerged/library/client/cache/redis"
        "github.com/ArtEmerged/library/client/db"
        "github.com/ArtEmerged/library/client/db/pg"
        "github.com/ArtEmerged/library/client/db/transaction"

        userGRPC "github.com/ArtEmerged/o_auth-server/internal/api/grpc/user"
        "github.com/ArtEmerged/o_auth-server/internal/closer"
        "github.com/ArtEmerged/o_auth-server/internal/config"
        "github.com/ArtEmerged/o_auth-server/internal/repository"
        userRepo "github.com/ArtEmerged/o_auth-server/internal/repository/user"
        "github.com/ArtEmerged/o_auth-server/internal/service"
        userServ "github.com/ArtEmerged/o_auth-server/internal/service/user"
)

type serviceProvider struct {
        globalConfig *config.Config
        redisConfig  redis.Config

        dbClient  db.Client
        txManager db.TxManager
        cache     cache.Cache

        userRepository repository.UserRepo

        userService service.UserService

        userImpl *userGRPC.Implementation
}

func newServiceProvider() *serviceProvider <span class="cov0" title="0">{
        return &amp;serviceProvider{}
}</span>

// GlobalConfig initializes and returns the global config.
func (s *serviceProvider) GlobalConfig() *config.Config <span class="cov0" title="0">{
        if s.globalConfig == nil </span><span class="cov0" title="0">{
                s.globalConfig = config.New()

                err := s.globalConfig.Init("")
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed init config: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return s.globalConfig</span>
}

// RedisConfig returns the redis config.
func (s *serviceProvider) RedisConfig() redis.Config <span class="cov0" title="0">{
        if s.redisConfig == nil </span><span class="cov0" title="0">{
                s.redisConfig = s.GlobalConfig().RedisConfig()
        }</span>

        <span class="cov0" title="0">return s.redisConfig</span>
}

// DBClient initializes and returns the database client.
func (s *serviceProvider) DBClient(ctx context.Context) db.Client <span class="cov0" title="0">{
        if s.dbClient == nil </span><span class="cov0" title="0">{
                cl, err := pg.New(ctx, s.GlobalConfig().DbDNS())
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to create db client: %v", err)
                }</span>

                <span class="cov0" title="0">err = cl.DB().Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to ping db: %v", err)
                }</span>
                <span class="cov0" title="0">closer.Add(cl.Close)

                s.dbClient = cl</span>
        }

        <span class="cov0" title="0">return s.dbClient</span>
}

// TxManager initializes and returns the transaction manager.
func (s *serviceProvider) TxManager(ctx context.Context) db.TxManager <span class="cov0" title="0">{

        if s.txManager == nil </span><span class="cov0" title="0">{
                s.txManager = transaction.NewTransactionManager(s.DBClient(ctx).DB())
        }</span>

        <span class="cov0" title="0">return s.txManager</span>
}

// Cache returns the cache.
func (s *serviceProvider) Cache(ctx context.Context) cache.Cache <span class="cov0" title="0">{
        if s.cache == nil </span><span class="cov0" title="0">{
                s.cache = redis.NewClient(s.RedisConfig())
                err := s.cache.Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to ping redis: %v", err)
                }</span>

                <span class="cov0" title="0">closer.Add(s.cache.Close)</span>
        }

        <span class="cov0" title="0">return s.cache</span>
}

// UserRepository returns the user repository.
func (s *serviceProvider) UserRepository(ctx context.Context) repository.UserRepo <span class="cov0" title="0">{
        if s.userRepository == nil </span><span class="cov0" title="0">{
                s.userRepository = userRepo.New(s.DBClient(ctx), s.Cache(ctx))
        }</span>

        <span class="cov0" title="0">return s.userRepository</span>
}

// UserService returns the user service.
func (s *serviceProvider) UserService(ctx context.Context) service.UserService <span class="cov0" title="0">{
        if s.userService == nil </span><span class="cov0" title="0">{
                s.userService = userServ.New(s.UserRepository(ctx), s.TxManager(ctx), s.Cache(ctx), s.GlobalConfig().Salt())
        }</span>

        <span class="cov0" title="0">return s.userService</span>
}

// UserImplementation returns the user gRPC implementation.
func (s *serviceProvider) UserImplementation(ctx context.Context) *userGRPC.Implementation <span class="cov0" title="0">{
        if s.userImpl == nil </span><span class="cov0" title="0">{
                s.userImpl = userGRPC.NewImplementation(s.UserService(ctx))
        }</span>

        <span class="cov0" title="0">return s.userImpl</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package closer

import (
        "log"
        "os"
        "os/signal"
        "sync"
)

var globalCloser = New()

// Add adds new closers
func Add(fs ...func() error) <span class="cov0" title="0">{
        globalCloser.Add(fs...)
}</span>

// Wite wites all closers
func Wite() <span class="cov0" title="0">{
        globalCloser.Wite()
}</span>

// CloseAll closes all closers functions
func CloseAll() <span class="cov0" title="0">{
        globalCloser.CloseAll()
}</span>

// Closer closes all closers
type Closer struct {
        done chan struct{}
        once sync.Once
        mu   sync.RWMutex
        fs   []func() error
}

// New creates a new instance of Closer
func New(signals ...os.Signal) *Closer <span class="cov0" title="0">{
        c := &amp;Closer{done: make(chan struct{})}

        if len(signals) &gt; 0 </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        sign := make(chan os.Signal, 1)
                        signal.Notify(sign, signals...)
                        &lt;-sign
                        signal.Stop(sign)

                        c.CloseAll()
                }</span>()

        }

        <span class="cov0" title="0">return c</span>
}

// Add adds new closers
func (c *Closer) Add(fs ...func() error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.fs = append(c.fs, fs...)
}</span>

// Wite wites all closers
func (c *Closer) Wite() <span class="cov0" title="0">{
        &lt;-c.done
}</span>

// CloseAll closes all closers functions
func (c *Closer) CloseAll() <span class="cov0" title="0">{
        c.once.Do(func() </span><span class="cov0" title="0">{
                defer close(c.done)

                c.mu.Lock()
                fs := c.fs
                c.fs = nil
                c.mu.Unlock()

                errs := make(chan error, len(fs))

                for _, f := range fs </span><span class="cov0" title="0">{
                        go func(f func() error) </span><span class="cov0" title="0">{
                                errs &lt;- f()
                        }</span>(f)
                }

                <span class="cov0" title="0">for i := 0; i &lt; cap(errs); i++ </span><span class="cov0" title="0">{
                        if err := &lt;-errs; err != nil </span><span class="cov0" title="0">{
                                log.Println("error returned from Closer")
                        }</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "fmt"
        "net"
        "time"

        "github.com/joho/godotenv"
        "github.com/kelseyhightower/envconfig"
)

const (
        serverHost     = "localhost"
        defaultEnvFile = ".env"
)

// Config is the config struct.
type Config struct {
        ServerPort string `envconfig:"SERVER_PORT" default:"50051"`

        DBName     string `envconfig:"DB_NAME"`
        DBHost     string `envconfig:"DB_HOST"`
        DBPort     string `envconfig:"DB_PORT"`
        DBUser     string `envconfig:"DB_USER"`
        DBPassword string `envconfig:"DB_PASSWORD"`

        SaltPassword string `envconfig:"SALT_PASSWORD"`

        RedisHost              string        `envconfig:"REDIS_HOST"`
        RedisPort              string        `envconfig:"REDIS_PORT"`
        RedisMaxIdleConns      int           `envconfig:"REDIS_MAX_IDLE"`
        RedisConnectionTimeout time.Duration `envconfig:"REDIS_CONNECTION_TIMEOUT"`
        RedisIdleTimeout       time.Duration `envconfig:"REDIS_IDLE_TIMEOUT_SEC"`
}

// New creates a new config.
func New() *Config <span class="cov0" title="0">{
        return &amp;Config{}
}</span>

// Init initializes the config.
func (cfg *Config) Init(path string) error <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                path = defaultEnvFile
        }</span>

        <span class="cov0" title="0">err := godotenv.Load(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed load env: %w", err)
        }</span>

        <span class="cov0" title="0">err = envconfig.Process("", cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed parse env: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDbDNS returns the database connection string.
func (cfg *Config) DbDNS() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=disable",
                cfg.DBHost, cfg.DBPort, cfg.DBName, cfg.DBUser, cfg.DBPassword)
}</span>

// GetSalt returns the salt password.
func (cfg *Config) Salt() string <span class="cov0" title="0">{
        return cfg.SaltPassword
}</span>

// GetServerAddress returns the server address.
func (cfg *Config) ServerAddress() string <span class="cov0" title="0">{
        return net.JoinHostPort(serverHost, cfg.ServerPort)
}</span>

type redisConfig struct {
        Host              string
        Port              string
        maxIdleConns      int
        connectionTimeout time.Duration
        idleTimeout       time.Duration
}

// RedisConfig returns the redis config.
func (cfg *Config) RedisConfig() *redisConfig <span class="cov0" title="0">{
        return &amp;redisConfig{
                Host:              cfg.RedisHost,
                Port:              cfg.RedisPort,
                maxIdleConns:      cfg.RedisMaxIdleConns,
                connectionTimeout: cfg.RedisConnectionTimeout,
                idleTimeout:       cfg.RedisIdleTimeout,
        }
}</span>

// Address returns the redis address.
func (r redisConfig) Address() string <span class="cov0" title="0">{
        return net.JoinHostPort(r.Host, r.Port)
}</span>

// MaxIdle returns the max idle connections.
func (r redisConfig) ConnectionTimeout() time.Duration <span class="cov0" title="0">{
        return r.connectionTimeout
}</span>

// MaxIdle returns the max idle connections.
func (r redisConfig) MaxIdle() int <span class="cov0" title="0">{
        return int(r.maxIdleConns)
}</span>

// IdleTimeout returns the idle timeout.
func (r redisConfig) IdleTimeout() time.Duration <span class="cov0" title="0">{
        return r.idleTimeout
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package model

import (
        "fmt"
        "strings"
        "time"
)

const userCacheKey = "users:user:%d"

// UserCacheKey returns key for chat
func UserCacheKey(chatID int64) string <span class="cov8" title="1">{
        return fmt.Sprintf(userCacheKey, chatID)
}</span>

// Role represents a user role.
type Role int32

const (
        // RoleUnknown represents an unknown role.
        RoleUnknown Role = iota
        // RoleUser represents the user role with normal permissions.
        RoleUser
        // RoleAdmin represents the admin role with all permissions.
        RoleAdmin
)

// Status represents a user status.
type Status string

const (
        // StatusUnknown represents a user status unknown (default).
        StatusUnknown Status = "UNKNOWN"
        // StatusActive represents a active user.
        StatusActive Status = "ACTIVE"
        // StatusBlocked represents a blocked user.
        StatusBlocked Status = "BLOCKED"
        // StatusDeleted represents a deleted user.
        StatusDeleted Status = "DELETED"
)

// UpdateUserRequest represents an update user request.
type UpdateUserRequest struct {
        ID   int64
        Name string
        Role Role
}

// Validate - validates the update user request.
func (r *UpdateUserRequest) Validate() error <span class="cov8" title="1">{
        if r.Name == "" &amp;&amp; r.Role == RoleUnknown </span><span class="cov8" title="1">{
                return ErrWithoutChanges
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UserInfo represents a user information.
type UserInfo struct {
        ID        int64      `json:"id"`
        Name      string     `json:"name"`
        Email     string     `json:"email"`
        CreatedAt time.Time  `json:"created_at"`
        UpdatedAt *time.Time `json:"updated_at"`
        Role      Role       `json:"role"`
}

// CreateUserRequest represents a create user request.
type CreateUserRequest struct {
        Name            string
        Email           string
        Password        string
        PasswordConfirm string
        PasswordHash    string
        Role            Role
}

// Validate - validates the create user request.
func (r *CreateUserRequest) Validate() error <span class="cov8" title="1">{
        var errsText []string

        // validate required fields
        if r.Name == "" </span><span class="cov8" title="1">{
                errsText = append(errsText, "field name is required")
        }</span>
        <span class="cov8" title="1">if r.Email == "" </span><span class="cov8" title="1">{
                errsText = append(errsText, "field email is required")
        }</span>
        <span class="cov8" title="1">if r.Password == "" </span><span class="cov8" title="1">{
                errsText = append(errsText, "field password is required")
        }</span>
        <span class="cov8" title="1">if r.PasswordConfirm == "" </span><span class="cov8" title="1">{
                errsText = append(errsText, "field password_confirm is required")
        }</span>

        // validate password
        <span class="cov8" title="1">if r.Password != r.PasswordConfirm </span><span class="cov8" title="1">{
                errsText = append(errsText, "password and password_confirm don't match")
        }</span>

        <span class="cov8" title="1">if len(errsText) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrInvalidArgument, strings.Join(errsText, ", "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ArtEmerged/o_auth-server/internal/repository.UserRepo -o user_repo_minimock.go -n UserRepoMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        "time"
        mm_time "time"

        "github.com/ArtEmerged/o_auth-server/internal/model"
        "github.com/gojuno/minimock/v3"
)

// UserRepoMock implements repository.UserRepo
type UserRepoMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreateUser          func(ctx context.Context, user *model.CreateUserRequest) (up1 *model.UserInfo, err error)
        inspectFuncCreateUser   func(ctx context.Context, user *model.CreateUserRequest)
        afterCreateUserCounter  uint64
        beforeCreateUserCounter uint64
        CreateUserMock          mUserRepoMockCreateUser

        funcDeleteUser          func(ctx context.Context, id int64) (err error)
        inspectFuncDeleteUser   func(ctx context.Context, id int64)
        afterDeleteUserCounter  uint64
        beforeDeleteUserCounter uint64
        DeleteUserMock          mUserRepoMockDeleteUser

        funcGetUser          func(ctx context.Context, id int64) (up1 *model.UserInfo, err error)
        inspectFuncGetUser   func(ctx context.Context, id int64)
        afterGetUserCounter  uint64
        beforeGetUserCounter uint64
        GetUserMock          mUserRepoMockGetUser

        funcUpdateUser          func(ctx context.Context, user *model.UpdateUserRequest) (updateAt time.Time, err error)
        inspectFuncUpdateUser   func(ctx context.Context, user *model.UpdateUserRequest)
        afterUpdateUserCounter  uint64
        beforeUpdateUserCounter uint64
        UpdateUserMock          mUserRepoMockUpdateUser
}

// NewUserRepoMock returns a mock for repository.UserRepo
func NewUserRepoMock(t minimock.Tester) *UserRepoMock <span class="cov8" title="1">{
        m := &amp;UserRepoMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.CreateUserMock = mUserRepoMockCreateUser{mock: m}
        m.CreateUserMock.callArgs = []*UserRepoMockCreateUserParams{}

        m.DeleteUserMock = mUserRepoMockDeleteUser{mock: m}
        m.DeleteUserMock.callArgs = []*UserRepoMockDeleteUserParams{}

        m.GetUserMock = mUserRepoMockGetUser{mock: m}
        m.GetUserMock.callArgs = []*UserRepoMockGetUserParams{}

        m.UpdateUserMock = mUserRepoMockUpdateUser{mock: m}
        m.UpdateUserMock.callArgs = []*UserRepoMockUpdateUserParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mUserRepoMockCreateUser struct {
        optional           bool
        mock               *UserRepoMock
        defaultExpectation *UserRepoMockCreateUserExpectation
        expectations       []*UserRepoMockCreateUserExpectation

        callArgs []*UserRepoMockCreateUserParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// UserRepoMockCreateUserExpectation specifies expectation struct of the UserRepo.CreateUser
type UserRepoMockCreateUserExpectation struct {
        mock      *UserRepoMock
        params    *UserRepoMockCreateUserParams
        paramPtrs *UserRepoMockCreateUserParamPtrs
        results   *UserRepoMockCreateUserResults
        Counter   uint64
}

// UserRepoMockCreateUserParams contains parameters of the UserRepo.CreateUser
type UserRepoMockCreateUserParams struct {
        ctx  context.Context
        user *model.CreateUserRequest
}

// UserRepoMockCreateUserParamPtrs contains pointers to parameters of the UserRepo.CreateUser
type UserRepoMockCreateUserParamPtrs struct {
        ctx  *context.Context
        user **model.CreateUserRequest
}

// UserRepoMockCreateUserResults contains results of the UserRepo.CreateUser
type UserRepoMockCreateUserResults struct {
        up1 *model.UserInfo
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserRepoMockCreateUser) Optional() *mUserRepoMockCreateUser <span class="cov0" title="0">{
        mmCreateUser.optional = true
        return mmCreateUser
}</span>

// Expect sets up expected params for UserRepo.CreateUser
func (mmCreateUser *mUserRepoMockCreateUser) Expect(ctx context.Context, user *model.CreateUserRequest) *mUserRepoMockCreateUser <span class="cov8" title="1">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserRepoMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmCreateUser.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmCreateUser.defaultExpectation = &amp;UserRepoMockCreateUserExpectation{}
        }</span>

        <span class="cov8" title="1">if mmCreateUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserRepoMock.CreateUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmCreateUser.defaultExpectation.params = &amp;UserRepoMockCreateUserParams{ctx, user}
        for _, e := range mmCreateUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmCreateUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserRepo.CreateUser
func (mmCreateUser *mUserRepoMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserRepoMockCreateUser <span class="cov0" title="0">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserRepoMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation = &amp;UserRepoMockCreateUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserRepoMock.CreateUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation.paramPtrs = &amp;UserRepoMockCreateUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateUser.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmCreateUser</span>
}

// ExpectUserParam2 sets up expected param user for UserRepo.CreateUser
func (mmCreateUser *mUserRepoMockCreateUser) ExpectUserParam2(user *model.CreateUserRequest) *mUserRepoMockCreateUser <span class="cov0" title="0">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserRepoMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation = &amp;UserRepoMockCreateUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserRepoMock.CreateUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation.paramPtrs = &amp;UserRepoMockCreateUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateUser.defaultExpectation.paramPtrs.user = &amp;user

        return mmCreateUser</span>
}

// Inspect accepts an inspector function that has same arguments as the UserRepo.CreateUser
func (mmCreateUser *mUserRepoMockCreateUser) Inspect(f func(ctx context.Context, user *model.CreateUserRequest)) *mUserRepoMockCreateUser <span class="cov0" title="0">{
        if mmCreateUser.mock.inspectFuncCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserRepoMock.CreateUser")
        }</span>

        <span class="cov0" title="0">mmCreateUser.mock.inspectFuncCreateUser = f

        return mmCreateUser</span>
}

// Return sets up results that will be returned by UserRepo.CreateUser
func (mmCreateUser *mUserRepoMockCreateUser) Return(up1 *model.UserInfo, err error) *UserRepoMock <span class="cov8" title="1">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserRepoMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmCreateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation = &amp;UserRepoMockCreateUserExpectation{mock: mmCreateUser.mock}
        }</span>
        <span class="cov8" title="1">mmCreateUser.defaultExpectation.results = &amp;UserRepoMockCreateUserResults{up1, err}
        return mmCreateUser.mock</span>
}

// Set uses given function f to mock the UserRepo.CreateUser method
func (mmCreateUser *mUserRepoMockCreateUser) Set(f func(ctx context.Context, user *model.CreateUserRequest) (up1 *model.UserInfo, err error)) *UserRepoMock <span class="cov0" title="0">{
        if mmCreateUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserRepo.CreateUser method")
        }</span>

        <span class="cov0" title="0">if len(mmCreateUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserRepo.CreateUser method")
        }</span>

        <span class="cov0" title="0">mmCreateUser.mock.funcCreateUser = f
        return mmCreateUser.mock</span>
}

// When sets expectation for the UserRepo.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserRepoMockCreateUser) When(ctx context.Context, user *model.CreateUserRequest) *UserRepoMockCreateUserExpectation <span class="cov0" title="0">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserRepoMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserRepoMockCreateUserExpectation{
                mock:   mmCreateUser.mock,
                params: &amp;UserRepoMockCreateUserParams{ctx, user},
        }
        mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
        return expectation</span>
}

// Then sets up UserRepo.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserRepoMockCreateUserExpectation) Then(up1 *model.UserInfo, err error) *UserRepoMock <span class="cov0" title="0">{
        e.results = &amp;UserRepoMockCreateUserResults{up1, err}
        return e.mock
}</span>

// Times sets number of times UserRepo.CreateUser should be invoked
func (mmCreateUser *mUserRepoMockCreateUser) Times(n uint64) *mUserRepoMockCreateUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("Times of UserRepoMock.CreateUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreateUser.expectedInvocations, n)
        return mmCreateUser</span>
}

func (mmCreateUser *mUserRepoMockCreateUser) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmCreateUser.expectations) == 0 &amp;&amp; mmCreateUser.defaultExpectation == nil &amp;&amp; mmCreateUser.mock.funcCreateUser == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreateUser.mock.afterCreateUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreateUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CreateUser implements repository.UserRepo
func (mmCreateUser *UserRepoMock) CreateUser(ctx context.Context, user *model.CreateUserRequest) (up1 *model.UserInfo, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmCreateUser.beforeCreateUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreateUser.afterCreateUserCounter, 1)

        if mmCreateUser.inspectFuncCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.inspectFuncCreateUser(ctx, user)
        }</span>

        <span class="cov8" title="1">mm_params := UserRepoMockCreateUserParams{ctx, user}

        // Record call args
        mmCreateUser.CreateUserMock.mutex.Lock()
        mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &amp;mm_params)
        mmCreateUser.CreateUserMock.mutex.Unlock()

        for _, e := range mmCreateUser.CreateUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.up1, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmCreateUser.CreateUserMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
                mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
                mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

                mm_got := UserRepoMockCreateUserParams{ctx, user}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreateUser.t.Errorf("UserRepoMock.CreateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.user != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.user, mm_got.user) </span><span class="cov0" title="0">{
                                mmCreateUser.t.Errorf("UserRepoMock.CreateUser got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreateUser.t.Errorf("UserRepoMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreateUser.t.Fatal("No results are set for the UserRepoMock.CreateUser")
                }</span>
                <span class="cov8" title="1">return (*mm_results).up1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreateUser.funcCreateUser != nil </span><span class="cov0" title="0">{
                return mmCreateUser.funcCreateUser(ctx, user)
        }</span>
        <span class="cov0" title="0">mmCreateUser.t.Fatalf("Unexpected call to UserRepoMock.CreateUser. %v %v", ctx, user)
        return</span>
}

// CreateUserAfterCounter returns a count of finished UserRepoMock.CreateUser invocations
func (mmCreateUser *UserRepoMock) CreateUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateUser.afterCreateUserCounter)
}</span>

// CreateUserBeforeCounter returns a count of UserRepoMock.CreateUser invocations
func (mmCreateUser *UserRepoMock) CreateUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateUser.beforeCreateUserCounter)
}</span>

// Calls returns a list of arguments used in each call to UserRepoMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserRepoMockCreateUser) Calls() []*UserRepoMockCreateUserParams <span class="cov0" title="0">{
        mmCreateUser.mutex.RLock()

        argCopy := make([]*UserRepoMockCreateUserParams, len(mmCreateUser.callArgs))
        copy(argCopy, mmCreateUser.callArgs)

        mmCreateUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserRepoMock) MinimockCreateUserDone() bool <span class="cov8" title="1">{
        if m.CreateUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.CreateUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.CreateUserMock.invocationsDone()</span>
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserRepoMock) MinimockCreateUserInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepoMock.CreateUser with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateUserCounter := mm_atomic.LoadUint64(&amp;m.afterCreateUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateUserMock.defaultExpectation != nil &amp;&amp; afterCreateUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to UserRepoMock.CreateUser")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserRepoMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreateUser != nil &amp;&amp; afterCreateUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to UserRepoMock.CreateUser")
        }</span>

        <span class="cov0" title="0">if !m.CreateUserMock.invocationsDone() &amp;&amp; afterCreateUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserRepoMock.CreateUser but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateUserMock.expectedInvocations), afterCreateUserCounter)
        }</span>
}

type mUserRepoMockDeleteUser struct {
        optional           bool
        mock               *UserRepoMock
        defaultExpectation *UserRepoMockDeleteUserExpectation
        expectations       []*UserRepoMockDeleteUserExpectation

        callArgs []*UserRepoMockDeleteUserParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// UserRepoMockDeleteUserExpectation specifies expectation struct of the UserRepo.DeleteUser
type UserRepoMockDeleteUserExpectation struct {
        mock      *UserRepoMock
        params    *UserRepoMockDeleteUserParams
        paramPtrs *UserRepoMockDeleteUserParamPtrs
        results   *UserRepoMockDeleteUserResults
        Counter   uint64
}

// UserRepoMockDeleteUserParams contains parameters of the UserRepo.DeleteUser
type UserRepoMockDeleteUserParams struct {
        ctx context.Context
        id  int64
}

// UserRepoMockDeleteUserParamPtrs contains pointers to parameters of the UserRepo.DeleteUser
type UserRepoMockDeleteUserParamPtrs struct {
        ctx *context.Context
        id  *int64
}

// UserRepoMockDeleteUserResults contains results of the UserRepo.DeleteUser
type UserRepoMockDeleteUserResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserRepoMockDeleteUser) Optional() *mUserRepoMockDeleteUser <span class="cov0" title="0">{
        mmDeleteUser.optional = true
        return mmDeleteUser
}</span>

// Expect sets up expected params for UserRepo.DeleteUser
func (mmDeleteUser *mUserRepoMockDeleteUser) Expect(ctx context.Context, id int64) *mUserRepoMockDeleteUser <span class="cov8" title="1">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserRepoMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmDeleteUser.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmDeleteUser.defaultExpectation = &amp;UserRepoMockDeleteUserExpectation{}
        }</span>

        <span class="cov8" title="1">if mmDeleteUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserRepoMock.DeleteUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmDeleteUser.defaultExpectation.params = &amp;UserRepoMockDeleteUserParams{ctx, id}
        for _, e := range mmDeleteUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmDeleteUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserRepo.DeleteUser
func (mmDeleteUser *mUserRepoMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserRepoMockDeleteUser <span class="cov0" title="0">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserRepoMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation = &amp;UserRepoMockDeleteUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserRepoMock.DeleteUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation.paramPtrs = &amp;UserRepoMockDeleteUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteUser.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmDeleteUser</span>
}

// ExpectIdParam2 sets up expected param id for UserRepo.DeleteUser
func (mmDeleteUser *mUserRepoMockDeleteUser) ExpectIdParam2(id int64) *mUserRepoMockDeleteUser <span class="cov0" title="0">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserRepoMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation = &amp;UserRepoMockDeleteUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserRepoMock.DeleteUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation.paramPtrs = &amp;UserRepoMockDeleteUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteUser.defaultExpectation.paramPtrs.id = &amp;id

        return mmDeleteUser</span>
}

// Inspect accepts an inspector function that has same arguments as the UserRepo.DeleteUser
func (mmDeleteUser *mUserRepoMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mUserRepoMockDeleteUser <span class="cov0" title="0">{
        if mmDeleteUser.mock.inspectFuncDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserRepoMock.DeleteUser")
        }</span>

        <span class="cov0" title="0">mmDeleteUser.mock.inspectFuncDeleteUser = f

        return mmDeleteUser</span>
}

// Return sets up results that will be returned by UserRepo.DeleteUser
func (mmDeleteUser *mUserRepoMockDeleteUser) Return(err error) *UserRepoMock <span class="cov8" title="1">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserRepoMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmDeleteUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation = &amp;UserRepoMockDeleteUserExpectation{mock: mmDeleteUser.mock}
        }</span>
        <span class="cov8" title="1">mmDeleteUser.defaultExpectation.results = &amp;UserRepoMockDeleteUserResults{err}
        return mmDeleteUser.mock</span>
}

// Set uses given function f to mock the UserRepo.DeleteUser method
func (mmDeleteUser *mUserRepoMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *UserRepoMock <span class="cov0" title="0">{
        if mmDeleteUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserRepo.DeleteUser method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserRepo.DeleteUser method")
        }</span>

        <span class="cov0" title="0">mmDeleteUser.mock.funcDeleteUser = f
        return mmDeleteUser.mock</span>
}

// When sets expectation for the UserRepo.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserRepoMockDeleteUser) When(ctx context.Context, id int64) *UserRepoMockDeleteUserExpectation <span class="cov0" title="0">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserRepoMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserRepoMockDeleteUserExpectation{
                mock:   mmDeleteUser.mock,
                params: &amp;UserRepoMockDeleteUserParams{ctx, id},
        }
        mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
        return expectation</span>
}

// Then sets up UserRepo.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserRepoMockDeleteUserExpectation) Then(err error) *UserRepoMock <span class="cov0" title="0">{
        e.results = &amp;UserRepoMockDeleteUserResults{err}
        return e.mock
}</span>

// Times sets number of times UserRepo.DeleteUser should be invoked
func (mmDeleteUser *mUserRepoMockDeleteUser) Times(n uint64) *mUserRepoMockDeleteUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("Times of UserRepoMock.DeleteUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteUser.expectedInvocations, n)
        return mmDeleteUser</span>
}

func (mmDeleteUser *mUserRepoMockDeleteUser) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmDeleteUser.expectations) == 0 &amp;&amp; mmDeleteUser.defaultExpectation == nil &amp;&amp; mmDeleteUser.mock.funcDeleteUser == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteUser.mock.afterDeleteUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteUser implements repository.UserRepo
func (mmDeleteUser *UserRepoMock) DeleteUser(ctx context.Context, id int64) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmDeleteUser.beforeDeleteUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteUser.afterDeleteUserCounter, 1)

        if mmDeleteUser.inspectFuncDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.inspectFuncDeleteUser(ctx, id)
        }</span>

        <span class="cov8" title="1">mm_params := UserRepoMockDeleteUserParams{ctx, id}

        // Record call args
        mmDeleteUser.DeleteUserMock.mutex.Lock()
        mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &amp;mm_params)
        mmDeleteUser.DeleteUserMock.mutex.Unlock()

        for _, e := range mmDeleteUser.DeleteUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmDeleteUser.DeleteUserMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

                mm_got := UserRepoMockDeleteUserParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDeleteUser.t.Errorf("UserRepoMock.DeleteUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDeleteUser.t.Errorf("UserRepoMock.DeleteUser got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteUser.t.Errorf("UserRepoMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDeleteUser.t.Fatal("No results are set for the UserRepoMock.DeleteUser")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDeleteUser.funcDeleteUser != nil </span><span class="cov0" title="0">{
                return mmDeleteUser.funcDeleteUser(ctx, id)
        }</span>
        <span class="cov0" title="0">mmDeleteUser.t.Fatalf("Unexpected call to UserRepoMock.DeleteUser. %v %v", ctx, id)
        return</span>
}

// DeleteUserAfterCounter returns a count of finished UserRepoMock.DeleteUser invocations
func (mmDeleteUser *UserRepoMock) DeleteUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteUser.afterDeleteUserCounter)
}</span>

// DeleteUserBeforeCounter returns a count of UserRepoMock.DeleteUser invocations
func (mmDeleteUser *UserRepoMock) DeleteUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteUser.beforeDeleteUserCounter)
}</span>

// Calls returns a list of arguments used in each call to UserRepoMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserRepoMockDeleteUser) Calls() []*UserRepoMockDeleteUserParams <span class="cov0" title="0">{
        mmDeleteUser.mutex.RLock()

        argCopy := make([]*UserRepoMockDeleteUserParams, len(mmDeleteUser.callArgs))
        copy(argCopy, mmDeleteUser.callArgs)

        mmDeleteUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserRepoMock) MinimockDeleteUserDone() bool <span class="cov8" title="1">{
        if m.DeleteUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.DeleteUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.DeleteUserMock.invocationsDone()</span>
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserRepoMock) MinimockDeleteUserInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepoMock.DeleteUser with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteUserCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteUserMock.defaultExpectation != nil &amp;&amp; afterDeleteUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to UserRepoMock.DeleteUser")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserRepoMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteUser != nil &amp;&amp; afterDeleteUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to UserRepoMock.DeleteUser")
        }</span>

        <span class="cov0" title="0">if !m.DeleteUserMock.invocationsDone() &amp;&amp; afterDeleteUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserRepoMock.DeleteUser but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteUserMock.expectedInvocations), afterDeleteUserCounter)
        }</span>
}

type mUserRepoMockGetUser struct {
        optional           bool
        mock               *UserRepoMock
        defaultExpectation *UserRepoMockGetUserExpectation
        expectations       []*UserRepoMockGetUserExpectation

        callArgs []*UserRepoMockGetUserParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// UserRepoMockGetUserExpectation specifies expectation struct of the UserRepo.GetUser
type UserRepoMockGetUserExpectation struct {
        mock      *UserRepoMock
        params    *UserRepoMockGetUserParams
        paramPtrs *UserRepoMockGetUserParamPtrs
        results   *UserRepoMockGetUserResults
        Counter   uint64
}

// UserRepoMockGetUserParams contains parameters of the UserRepo.GetUser
type UserRepoMockGetUserParams struct {
        ctx context.Context
        id  int64
}

// UserRepoMockGetUserParamPtrs contains pointers to parameters of the UserRepo.GetUser
type UserRepoMockGetUserParamPtrs struct {
        ctx *context.Context
        id  *int64
}

// UserRepoMockGetUserResults contains results of the UserRepo.GetUser
type UserRepoMockGetUserResults struct {
        up1 *model.UserInfo
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserRepoMockGetUser) Optional() *mUserRepoMockGetUser <span class="cov0" title="0">{
        mmGetUser.optional = true
        return mmGetUser
}</span>

// Expect sets up expected params for UserRepo.GetUser
func (mmGetUser *mUserRepoMockGetUser) Expect(ctx context.Context, id int64) *mUserRepoMockGetUser <span class="cov8" title="1">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserRepoMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetUser.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmGetUser.defaultExpectation = &amp;UserRepoMockGetUserExpectation{}
        }</span>

        <span class="cov8" title="1">if mmGetUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserRepoMock.GetUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmGetUser.defaultExpectation.params = &amp;UserRepoMockGetUserParams{ctx, id}
        for _, e := range mmGetUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmGetUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserRepo.GetUser
func (mmGetUser *mUserRepoMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserRepoMockGetUser <span class="cov0" title="0">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserRepoMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation = &amp;UserRepoMockGetUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserRepoMock.GetUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation.paramPtrs = &amp;UserRepoMockGetUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetUser.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmGetUser</span>
}

// ExpectIdParam2 sets up expected param id for UserRepo.GetUser
func (mmGetUser *mUserRepoMockGetUser) ExpectIdParam2(id int64) *mUserRepoMockGetUser <span class="cov0" title="0">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserRepoMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation = &amp;UserRepoMockGetUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserRepoMock.GetUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation.paramPtrs = &amp;UserRepoMockGetUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetUser.defaultExpectation.paramPtrs.id = &amp;id

        return mmGetUser</span>
}

// Inspect accepts an inspector function that has same arguments as the UserRepo.GetUser
func (mmGetUser *mUserRepoMockGetUser) Inspect(f func(ctx context.Context, id int64)) *mUserRepoMockGetUser <span class="cov0" title="0">{
        if mmGetUser.mock.inspectFuncGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("Inspect function is already set for UserRepoMock.GetUser")
        }</span>

        <span class="cov0" title="0">mmGetUser.mock.inspectFuncGetUser = f

        return mmGetUser</span>
}

// Return sets up results that will be returned by UserRepo.GetUser
func (mmGetUser *mUserRepoMockGetUser) Return(up1 *model.UserInfo, err error) *UserRepoMock <span class="cov8" title="1">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserRepoMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation = &amp;UserRepoMockGetUserExpectation{mock: mmGetUser.mock}
        }</span>
        <span class="cov8" title="1">mmGetUser.defaultExpectation.results = &amp;UserRepoMockGetUserResults{up1, err}
        return mmGetUser.mock</span>
}

// Set uses given function f to mock the UserRepo.GetUser method
func (mmGetUser *mUserRepoMockGetUser) Set(f func(ctx context.Context, id int64) (up1 *model.UserInfo, err error)) *UserRepoMock <span class="cov0" title="0">{
        if mmGetUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("Default expectation is already set for the UserRepo.GetUser method")
        }</span>

        <span class="cov0" title="0">if len(mmGetUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("Some expectations are already set for the UserRepo.GetUser method")
        }</span>

        <span class="cov0" title="0">mmGetUser.mock.funcGetUser = f
        return mmGetUser.mock</span>
}

// When sets expectation for the UserRepo.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserRepoMockGetUser) When(ctx context.Context, id int64) *UserRepoMockGetUserExpectation <span class="cov0" title="0">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserRepoMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserRepoMockGetUserExpectation{
                mock:   mmGetUser.mock,
                params: &amp;UserRepoMockGetUserParams{ctx, id},
        }
        mmGetUser.expectations = append(mmGetUser.expectations, expectation)
        return expectation</span>
}

// Then sets up UserRepo.GetUser return parameters for the expectation previously defined by the When method
func (e *UserRepoMockGetUserExpectation) Then(up1 *model.UserInfo, err error) *UserRepoMock <span class="cov0" title="0">{
        e.results = &amp;UserRepoMockGetUserResults{up1, err}
        return e.mock
}</span>

// Times sets number of times UserRepo.GetUser should be invoked
func (mmGetUser *mUserRepoMockGetUser) Times(n uint64) *mUserRepoMockGetUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("Times of UserRepoMock.GetUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetUser.expectedInvocations, n)
        return mmGetUser</span>
}

func (mmGetUser *mUserRepoMockGetUser) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmGetUser.expectations) == 0 &amp;&amp; mmGetUser.defaultExpectation == nil &amp;&amp; mmGetUser.mock.funcGetUser == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetUser.mock.afterGetUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetUser implements repository.UserRepo
func (mmGetUser *UserRepoMock) GetUser(ctx context.Context, id int64) (up1 *model.UserInfo, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmGetUser.beforeGetUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetUser.afterGetUserCounter, 1)

        if mmGetUser.inspectFuncGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.inspectFuncGetUser(ctx, id)
        }</span>

        <span class="cov8" title="1">mm_params := UserRepoMockGetUserParams{ctx, id}

        // Record call args
        mmGetUser.GetUserMock.mutex.Lock()
        mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &amp;mm_params)
        mmGetUser.GetUserMock.mutex.Unlock()

        for _, e := range mmGetUser.GetUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.up1, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmGetUser.GetUserMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
                mm_want := mmGetUser.GetUserMock.defaultExpectation.params
                mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

                mm_got := UserRepoMockGetUserParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetUser.t.Errorf("UserRepoMock.GetUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmGetUser.t.Errorf("UserRepoMock.GetUser got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetUser.t.Errorf("UserRepoMock.GetUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmGetUser.GetUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetUser.t.Fatal("No results are set for the UserRepoMock.GetUser")
                }</span>
                <span class="cov8" title="1">return (*mm_results).up1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetUser.funcGetUser != nil </span><span class="cov0" title="0">{
                return mmGetUser.funcGetUser(ctx, id)
        }</span>
        <span class="cov0" title="0">mmGetUser.t.Fatalf("Unexpected call to UserRepoMock.GetUser. %v %v", ctx, id)
        return</span>
}

// GetUserAfterCounter returns a count of finished UserRepoMock.GetUser invocations
func (mmGetUser *UserRepoMock) GetUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetUser.afterGetUserCounter)
}</span>

// GetUserBeforeCounter returns a count of UserRepoMock.GetUser invocations
func (mmGetUser *UserRepoMock) GetUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetUser.beforeGetUserCounter)
}</span>

// Calls returns a list of arguments used in each call to UserRepoMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserRepoMockGetUser) Calls() []*UserRepoMockGetUserParams <span class="cov0" title="0">{
        mmGetUser.mutex.RLock()

        argCopy := make([]*UserRepoMockGetUserParams, len(mmGetUser.callArgs))
        copy(argCopy, mmGetUser.callArgs)

        mmGetUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserRepoMock) MinimockGetUserDone() bool <span class="cov8" title="1">{
        if m.GetUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.GetUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.GetUserMock.invocationsDone()</span>
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserRepoMock) MinimockGetUserInspect() <span class="cov0" title="0">{
        for _, e := range m.GetUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepoMock.GetUser with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetUserCounter := mm_atomic.LoadUint64(&amp;m.afterGetUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetUserMock.defaultExpectation != nil &amp;&amp; afterGetUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to UserRepoMock.GetUser")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserRepoMock.GetUser with params: %#v", *m.GetUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetUser != nil &amp;&amp; afterGetUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to UserRepoMock.GetUser")
        }</span>

        <span class="cov0" title="0">if !m.GetUserMock.invocationsDone() &amp;&amp; afterGetUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserRepoMock.GetUser but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetUserMock.expectedInvocations), afterGetUserCounter)
        }</span>
}

type mUserRepoMockUpdateUser struct {
        optional           bool
        mock               *UserRepoMock
        defaultExpectation *UserRepoMockUpdateUserExpectation
        expectations       []*UserRepoMockUpdateUserExpectation

        callArgs []*UserRepoMockUpdateUserParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// UserRepoMockUpdateUserExpectation specifies expectation struct of the UserRepo.UpdateUser
type UserRepoMockUpdateUserExpectation struct {
        mock      *UserRepoMock
        params    *UserRepoMockUpdateUserParams
        paramPtrs *UserRepoMockUpdateUserParamPtrs
        results   *UserRepoMockUpdateUserResults
        Counter   uint64
}

// UserRepoMockUpdateUserParams contains parameters of the UserRepo.UpdateUser
type UserRepoMockUpdateUserParams struct {
        ctx  context.Context
        user *model.UpdateUserRequest
}

// UserRepoMockUpdateUserParamPtrs contains pointers to parameters of the UserRepo.UpdateUser
type UserRepoMockUpdateUserParamPtrs struct {
        ctx  *context.Context
        user **model.UpdateUserRequest
}

// UserRepoMockUpdateUserResults contains results of the UserRepo.UpdateUser
type UserRepoMockUpdateUserResults struct {
        updateAt time.Time
        err      error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUserRepoMockUpdateUser) Optional() *mUserRepoMockUpdateUser <span class="cov0" title="0">{
        mmUpdateUser.optional = true
        return mmUpdateUser
}</span>

// Expect sets up expected params for UserRepo.UpdateUser
func (mmUpdateUser *mUserRepoMockUpdateUser) Expect(ctx context.Context, user *model.UpdateUserRequest) *mUserRepoMockUpdateUser <span class="cov8" title="1">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserRepoMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmUpdateUser.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmUpdateUser.defaultExpectation = &amp;UserRepoMockUpdateUserExpectation{}
        }</span>

        <span class="cov8" title="1">if mmUpdateUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserRepoMock.UpdateUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmUpdateUser.defaultExpectation.params = &amp;UserRepoMockUpdateUserParams{ctx, user}
        for _, e := range mmUpdateUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmUpdateUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserRepo.UpdateUser
func (mmUpdateUser *mUserRepoMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUserRepoMockUpdateUser <span class="cov0" title="0">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserRepoMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation = &amp;UserRepoMockUpdateUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserRepoMock.UpdateUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation.paramPtrs = &amp;UserRepoMockUpdateUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdateUser.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmUpdateUser</span>
}

// ExpectUserParam2 sets up expected param user for UserRepo.UpdateUser
func (mmUpdateUser *mUserRepoMockUpdateUser) ExpectUserParam2(user *model.UpdateUserRequest) *mUserRepoMockUpdateUser <span class="cov0" title="0">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserRepoMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation = &amp;UserRepoMockUpdateUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserRepoMock.UpdateUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation.paramPtrs = &amp;UserRepoMockUpdateUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdateUser.defaultExpectation.paramPtrs.user = &amp;user

        return mmUpdateUser</span>
}

// Inspect accepts an inspector function that has same arguments as the UserRepo.UpdateUser
func (mmUpdateUser *mUserRepoMockUpdateUser) Inspect(f func(ctx context.Context, user *model.UpdateUserRequest)) *mUserRepoMockUpdateUser <span class="cov0" title="0">{
        if mmUpdateUser.mock.inspectFuncUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UserRepoMock.UpdateUser")
        }</span>

        <span class="cov0" title="0">mmUpdateUser.mock.inspectFuncUpdateUser = f

        return mmUpdateUser</span>
}

// Return sets up results that will be returned by UserRepo.UpdateUser
func (mmUpdateUser *mUserRepoMockUpdateUser) Return(updateAt time.Time, err error) *UserRepoMock <span class="cov8" title="1">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserRepoMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmUpdateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation = &amp;UserRepoMockUpdateUserExpectation{mock: mmUpdateUser.mock}
        }</span>
        <span class="cov8" title="1">mmUpdateUser.defaultExpectation.results = &amp;UserRepoMockUpdateUserResults{updateAt, err}
        return mmUpdateUser.mock</span>
}

// Set uses given function f to mock the UserRepo.UpdateUser method
func (mmUpdateUser *mUserRepoMockUpdateUser) Set(f func(ctx context.Context, user *model.UpdateUserRequest) (updateAt time.Time, err error)) *UserRepoMock <span class="cov0" title="0">{
        if mmUpdateUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the UserRepo.UpdateUser method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdateUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the UserRepo.UpdateUser method")
        }</span>

        <span class="cov0" title="0">mmUpdateUser.mock.funcUpdateUser = f
        return mmUpdateUser.mock</span>
}

// When sets expectation for the UserRepo.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUserRepoMockUpdateUser) When(ctx context.Context, user *model.UpdateUserRequest) *UserRepoMockUpdateUserExpectation <span class="cov0" title="0">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserRepoMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserRepoMockUpdateUserExpectation{
                mock:   mmUpdateUser.mock,
                params: &amp;UserRepoMockUpdateUserParams{ctx, user},
        }
        mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
        return expectation</span>
}

// Then sets up UserRepo.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UserRepoMockUpdateUserExpectation) Then(updateAt time.Time, err error) *UserRepoMock <span class="cov0" title="0">{
        e.results = &amp;UserRepoMockUpdateUserResults{updateAt, err}
        return e.mock
}</span>

// Times sets number of times UserRepo.UpdateUser should be invoked
func (mmUpdateUser *mUserRepoMockUpdateUser) Times(n uint64) *mUserRepoMockUpdateUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("Times of UserRepoMock.UpdateUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdateUser.expectedInvocations, n)
        return mmUpdateUser</span>
}

func (mmUpdateUser *mUserRepoMockUpdateUser) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmUpdateUser.expectations) == 0 &amp;&amp; mmUpdateUser.defaultExpectation == nil &amp;&amp; mmUpdateUser.mock.funcUpdateUser == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdateUser.mock.afterUpdateUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdateUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// UpdateUser implements repository.UserRepo
func (mmUpdateUser *UserRepoMock) UpdateUser(ctx context.Context, user *model.UpdateUserRequest) (updateAt time.Time, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmUpdateUser.beforeUpdateUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdateUser.afterUpdateUserCounter, 1)

        if mmUpdateUser.inspectFuncUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.inspectFuncUpdateUser(ctx, user)
        }</span>

        <span class="cov8" title="1">mm_params := UserRepoMockUpdateUserParams{ctx, user}

        // Record call args
        mmUpdateUser.UpdateUserMock.mutex.Lock()
        mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &amp;mm_params)
        mmUpdateUser.UpdateUserMock.mutex.Unlock()

        for _, e := range mmUpdateUser.UpdateUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.updateAt, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmUpdateUser.UpdateUserMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
                mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

                mm_got := UserRepoMockUpdateUserParams{ctx, user}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdateUser.t.Errorf("UserRepoMock.UpdateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.user != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.user, mm_got.user) </span><span class="cov0" title="0">{
                                mmUpdateUser.t.Errorf("UserRepoMock.UpdateUser got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdateUser.t.Errorf("UserRepoMock.UpdateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdateUser.t.Fatal("No results are set for the UserRepoMock.UpdateUser")
                }</span>
                <span class="cov8" title="1">return (*mm_results).updateAt, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdateUser.funcUpdateUser != nil </span><span class="cov0" title="0">{
                return mmUpdateUser.funcUpdateUser(ctx, user)
        }</span>
        <span class="cov0" title="0">mmUpdateUser.t.Fatalf("Unexpected call to UserRepoMock.UpdateUser. %v %v", ctx, user)
        return</span>
}

// UpdateUserAfterCounter returns a count of finished UserRepoMock.UpdateUser invocations
func (mmUpdateUser *UserRepoMock) UpdateUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdateUser.afterUpdateUserCounter)
}</span>

// UpdateUserBeforeCounter returns a count of UserRepoMock.UpdateUser invocations
func (mmUpdateUser *UserRepoMock) UpdateUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdateUser.beforeUpdateUserCounter)
}</span>

// Calls returns a list of arguments used in each call to UserRepoMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUserRepoMockUpdateUser) Calls() []*UserRepoMockUpdateUserParams <span class="cov0" title="0">{
        mmUpdateUser.mutex.RLock()

        argCopy := make([]*UserRepoMockUpdateUserParams, len(mmUpdateUser.callArgs))
        copy(argCopy, mmUpdateUser.callArgs)

        mmUpdateUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UserRepoMock) MinimockUpdateUserDone() bool <span class="cov8" title="1">{
        if m.UpdateUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.UpdateUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.UpdateUserMock.invocationsDone()</span>
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UserRepoMock) MinimockUpdateUserInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepoMock.UpdateUser with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateUserCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateUserMock.defaultExpectation != nil &amp;&amp; afterUpdateUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to UserRepoMock.UpdateUser")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserRepoMock.UpdateUser with params: %#v", *m.UpdateUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdateUser != nil &amp;&amp; afterUpdateUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to UserRepoMock.UpdateUser")
        }</span>

        <span class="cov0" title="0">if !m.UpdateUserMock.invocationsDone() &amp;&amp; afterUpdateUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserRepoMock.UpdateUser but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateUserMock.expectedInvocations), afterUpdateUserCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepoMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateUserInspect()

                        m.MinimockDeleteUserInspect()

                        m.MinimockGetUserInspect()

                        m.MinimockUpdateUserInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepoMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *UserRepoMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateUserDone() &amp;&amp;
                m.MinimockDeleteUserDone() &amp;&amp;
                m.MinimockGetUserDone() &amp;&amp;
                m.MinimockUpdateUserDone()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package adapter

import (
        "time"

        "github.com/ArtEmerged/o_auth-server/internal/model"
        modelRepo "github.com/ArtEmerged/o_auth-server/internal/repository/user/model"
)

// CreateUserRequestToRepo adapts the CreateUserRequest to repo model.
func CreateUserRequestToRepo(in *model.CreateUserRequest) *modelRepo.CreateUserRequest <span class="cov0" title="0">{
        return &amp;modelRepo.CreateUserRequest{
                Name:         in.Name,
                Email:        in.Email,
                PasswordHash: in.PasswordHash,
                Role:         int32ToRoleEnum(int32(in.Role)),
                CreatedAt:    time.Now().UTC(),
        }
}</span>

// UpdateUserRequestToRepo adapts the UpdateUserRequest to repo model.
func UpdateUserRequestToRepo(in *model.UpdateUserRequest) *modelRepo.UpdateUserRequest <span class="cov0" title="0">{

        return &amp;modelRepo.UpdateUserRequest{
                ID:        in.ID,
                Name:      in.Name,
                Role:      int32ToRoleEnum(int32(in.Role)),
                UpdatedAt: time.Now().UTC(),
        }
}</span>

// UserInfoToLocal adapts the UserInfo to the local model.
func UserInfoToLocal(in *modelRepo.UserInfo) *model.UserInfo <span class="cov0" title="0">{
        out := &amp;model.UserInfo{
                ID:        in.ID,
                Name:      in.Name,
                Email:     in.Email,
                Role:      roleEnumToInt32(in.Role),
                CreatedAt: in.CreatedAt,
                UpdatedAt: in.UpdatedAt,
        }
        return out
}</span>

func int32ToRoleEnum(role int32) modelRepo.Role <span class="cov0" title="0">{
        switch role </span>{
        case 1:<span class="cov0" title="0">
                return "USER"</span>
        case 2:<span class="cov0" title="0">
                return "ADMIN"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

func roleEnumToInt32(role modelRepo.Role) model.Role <span class="cov0" title="0">{
        switch role </span>{
        case "USER":<span class="cov0" title="0">
                return 1</span>
        case "ADMIN":<span class="cov0" title="0">
                return 2</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package user

import (
        "context"
        "errors"
        "fmt"
        "log"

        "github.com/ArtEmerged/library/client/db"
        "github.com/jackc/pgconn"

        "github.com/ArtEmerged/o_auth-server/internal/model"
        "github.com/ArtEmerged/o_auth-server/internal/repository/user/adapter"
        modelRepo "github.com/ArtEmerged/o_auth-server/internal/repository/user/model"
)

// CreateUser creates a new user in the repository and returns the user ID.
func (r *userRepo) CreateUser(ctx context.Context, in *model.CreateUserRequest) (*model.UserInfo, error) <span class="cov0" title="0">{
        newUser := adapter.CreateUserRequestToRepo(in)

        query := `
        INSERT INTO public.users (name, email, pass_hash, created_at, status, role)
        VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, email, created_at, updated_at, role;`

        userInfo := new(modelRepo.UserInfo)

        q := db.Query{
                Name:     "user_repository.CreateUser",
                QueryRaw: query,
        }

        err := r.db.DB().ScanOneContext(
                ctx,
                userInfo,
                q,
                newUser.Name,
                newUser.Email,
                newUser.PasswordHash,
                newUser.CreatedAt,
                modelRepo.StatusActive,
                newUser.Role,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR: REPO: %s\n", err.Error())

                var pgErr *pgconn.PgError

                if errors.As(err, &amp;pgErr) </span><span class="cov0" title="0">{
                        if pgErr.Code == "23505" </span><span class="cov0" title="0">{ // duplicate key value violates unique constraint
                                return nil, fmt.Errorf("%w: %s", model.ErrAlreadyExists, pgErr.Message)
                        }</span>
                }

                <span class="cov0" title="0">return nil, fmt.Errorf("create user:%w", err)</span>
        }

        <span class="cov0" title="0">return adapter.UserInfoToLocal(userInfo), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package user

import (
        "context"
        "fmt"

        "github.com/ArtEmerged/library/client/db"

        modelRepo "github.com/ArtEmerged/o_auth-server/internal/repository/user/model"
)

// DeleteUser deletes a user from the repository by ID.
func (r *userRepo) DeleteUser(ctx context.Context, id int64) error <span class="cov0" title="0">{
        query := `
        UPDATE public.users 
        SET status = $1
        WHERE id = $2 AND status = $3;`

        q := db.Query{
                Name:     "user_repository.DeleteUser",
                QueryRaw: query,
        }

        _, err := r.db.DB().ExecContext(ctx, q, modelRepo.StatusDeleted, id, modelRepo.StatusActive)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete user:%w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package user

import (
        "context"
        "errors"
        "fmt"

        "github.com/ArtEmerged/library/client/db"
        "github.com/jackc/pgx/v4"

        "github.com/ArtEmerged/o_auth-server/internal/model"
        "github.com/ArtEmerged/o_auth-server/internal/repository/user/adapter"
        modelRepo "github.com/ArtEmerged/o_auth-server/internal/repository/user/model"
)

// GetUser retrieves a user from the repository by ID and returns the user information.
func (r *userRepo) GetUser(ctx context.Context, id int64) (*model.UserInfo, error) <span class="cov0" title="0">{
        query := `
        SELECT id, name, email, created_at, updated_at, role
        FROM public.users
        WHERE id = $1 AND status = $2;`

        q := db.Query{
                Name:     "user_repository.GetUser",
                QueryRaw: query,
        }

        userInfo := new(modelRepo.UserInfo)

        err := r.db.DB().ScanOneContext(ctx, userInfo, q, id, modelRepo.StatusActive)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user %w", model.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed get user:%w", err)</span>
        }

        <span class="cov0" title="0">return adapter.UserInfoToLocal(userInfo), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package user

import (
        "github.com/ArtEmerged/library/client/cache"
        dbClient "github.com/ArtEmerged/library/client/db"

        "github.com/ArtEmerged/o_auth-server/internal/repository"
)

type userRepo struct {
        db    dbClient.Client
        cache cache.Cache
}

// New creates a new instance of userRepo with the given database connection pool.
// db - database connection pool
func New(db dbClient.Client, cache cache.Cache) repository.UserRepo <span class="cov0" title="0">{
        return &amp;userRepo{
                db:    db,
                cache: cache,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package user

import (
        "context"
        "fmt"
        "time"

        "github.com/ArtEmerged/library/client/db"

        "github.com/ArtEmerged/o_auth-server/internal/model"
        "github.com/ArtEmerged/o_auth-server/internal/repository/user/adapter"
        modelRepo "github.com/ArtEmerged/o_auth-server/internal/repository/user/model"
)

// UpdateUser updates an existing user's information.
func (r *userRepo) UpdateUser(ctx context.Context, in *model.UpdateUserRequest) (updateAt time.Time, err error) <span class="cov0" title="0">{
        upUser := adapter.UpdateUserRequestToRepo(in)

        query := `
        UPDATE public.users
        SET name = $1, role = $2, updated_at = $3
        WHERE id = $4 AND status = $5;`

        q := db.Query{
                Name:     "user_repository.UpdateUser",
                QueryRaw: query,
        }

        _, err = r.db.DB().ExecContext(ctx, q, upUser.Name, upUser.Role, upUser.UpdatedAt, upUser.ID, modelRepo.StatusActive)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("updated user:%w", err)
        }</span>

        <span class="cov0" title="0">return upUser.UpdatedAt, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ArtEmerged/o_auth-server/internal/service.UserService -o user_service_minimock.go -n UserServiceMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/ArtEmerged/o_auth-server/internal/model"
        "github.com/gojuno/minimock/v3"
)

// UserServiceMock implements service.UserService
type UserServiceMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreateUser          func(ctx context.Context, user *model.CreateUserRequest) (id int64, err error)
        inspectFuncCreateUser   func(ctx context.Context, user *model.CreateUserRequest)
        afterCreateUserCounter  uint64
        beforeCreateUserCounter uint64
        CreateUserMock          mUserServiceMockCreateUser

        funcDeleteUser          func(ctx context.Context, id int64) (err error)
        inspectFuncDeleteUser   func(ctx context.Context, id int64)
        afterDeleteUserCounter  uint64
        beforeDeleteUserCounter uint64
        DeleteUserMock          mUserServiceMockDeleteUser

        funcGetUser          func(ctx context.Context, id int64) (up1 *model.UserInfo, err error)
        inspectFuncGetUser   func(ctx context.Context, id int64)
        afterGetUserCounter  uint64
        beforeGetUserCounter uint64
        GetUserMock          mUserServiceMockGetUser

        funcUpdateUser          func(ctx context.Context, user *model.UpdateUserRequest) (err error)
        inspectFuncUpdateUser   func(ctx context.Context, user *model.UpdateUserRequest)
        afterUpdateUserCounter  uint64
        beforeUpdateUserCounter uint64
        UpdateUserMock          mUserServiceMockUpdateUser
}

// NewUserServiceMock returns a mock for service.UserService
func NewUserServiceMock(t minimock.Tester) *UserServiceMock <span class="cov8" title="1">{
        m := &amp;UserServiceMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.CreateUserMock = mUserServiceMockCreateUser{mock: m}
        m.CreateUserMock.callArgs = []*UserServiceMockCreateUserParams{}

        m.DeleteUserMock = mUserServiceMockDeleteUser{mock: m}
        m.DeleteUserMock.callArgs = []*UserServiceMockDeleteUserParams{}

        m.GetUserMock = mUserServiceMockGetUser{mock: m}
        m.GetUserMock.callArgs = []*UserServiceMockGetUserParams{}

        m.UpdateUserMock = mUserServiceMockUpdateUser{mock: m}
        m.UpdateUserMock.callArgs = []*UserServiceMockUpdateUserParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mUserServiceMockCreateUser struct {
        optional           bool
        mock               *UserServiceMock
        defaultExpectation *UserServiceMockCreateUserExpectation
        expectations       []*UserServiceMockCreateUserExpectation

        callArgs []*UserServiceMockCreateUserParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// UserServiceMockCreateUserExpectation specifies expectation struct of the UserService.CreateUser
type UserServiceMockCreateUserExpectation struct {
        mock      *UserServiceMock
        params    *UserServiceMockCreateUserParams
        paramPtrs *UserServiceMockCreateUserParamPtrs
        results   *UserServiceMockCreateUserResults
        Counter   uint64
}

// UserServiceMockCreateUserParams contains parameters of the UserService.CreateUser
type UserServiceMockCreateUserParams struct {
        ctx  context.Context
        user *model.CreateUserRequest
}

// UserServiceMockCreateUserParamPtrs contains pointers to parameters of the UserService.CreateUser
type UserServiceMockCreateUserParamPtrs struct {
        ctx  *context.Context
        user **model.CreateUserRequest
}

// UserServiceMockCreateUserResults contains results of the UserService.CreateUser
type UserServiceMockCreateUserResults struct {
        id  int64
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserServiceMockCreateUser) Optional() *mUserServiceMockCreateUser <span class="cov0" title="0">{
        mmCreateUser.optional = true
        return mmCreateUser
}</span>

// Expect sets up expected params for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) Expect(ctx context.Context, user *model.CreateUserRequest) *mUserServiceMockCreateUser <span class="cov8" title="1">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmCreateUser.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmCreateUser.defaultExpectation = &amp;UserServiceMockCreateUserExpectation{}
        }</span>

        <span class="cov8" title="1">if mmCreateUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmCreateUser.defaultExpectation.params = &amp;UserServiceMockCreateUserParams{ctx, user}
        for _, e := range mmCreateUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmCreateUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockCreateUser <span class="cov0" title="0">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation = &amp;UserServiceMockCreateUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation.paramPtrs = &amp;UserServiceMockCreateUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateUser.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmCreateUser</span>
}

// ExpectUserParam2 sets up expected param user for UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) ExpectUserParam2(user *model.CreateUserRequest) *mUserServiceMockCreateUser <span class="cov0" title="0">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation = &amp;UserServiceMockCreateUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation.paramPtrs = &amp;UserServiceMockCreateUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateUser.defaultExpectation.paramPtrs.user = &amp;user

        return mmCreateUser</span>
}

// Inspect accepts an inspector function that has same arguments as the UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) Inspect(f func(ctx context.Context, user *model.CreateUserRequest)) *mUserServiceMockCreateUser <span class="cov0" title="0">{
        if mmCreateUser.mock.inspectFuncCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.CreateUser")
        }</span>

        <span class="cov0" title="0">mmCreateUser.mock.inspectFuncCreateUser = f

        return mmCreateUser</span>
}

// Return sets up results that will be returned by UserService.CreateUser
func (mmCreateUser *mUserServiceMockCreateUser) Return(id int64, err error) *UserServiceMock <span class="cov8" title="1">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmCreateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateUser.defaultExpectation = &amp;UserServiceMockCreateUserExpectation{mock: mmCreateUser.mock}
        }</span>
        <span class="cov8" title="1">mmCreateUser.defaultExpectation.results = &amp;UserServiceMockCreateUserResults{id, err}
        return mmCreateUser.mock</span>
}

// Set uses given function f to mock the UserService.CreateUser method
func (mmCreateUser *mUserServiceMockCreateUser) Set(f func(ctx context.Context, user *model.CreateUserRequest) (id int64, err error)) *UserServiceMock <span class="cov0" title="0">{
        if mmCreateUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserService.CreateUser method")
        }</span>

        <span class="cov0" title="0">if len(mmCreateUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserService.CreateUser method")
        }</span>

        <span class="cov0" title="0">mmCreateUser.mock.funcCreateUser = f
        return mmCreateUser.mock</span>
}

// When sets expectation for the UserService.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserServiceMockCreateUser) When(ctx context.Context, user *model.CreateUserRequest) *UserServiceMockCreateUserExpectation <span class="cov0" title="0">{
        if mmCreateUser.mock.funcCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("UserServiceMock.CreateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserServiceMockCreateUserExpectation{
                mock:   mmCreateUser.mock,
                params: &amp;UserServiceMockCreateUserParams{ctx, user},
        }
        mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
        return expectation</span>
}

// Then sets up UserService.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockCreateUserExpectation) Then(id int64, err error) *UserServiceMock <span class="cov0" title="0">{
        e.results = &amp;UserServiceMockCreateUserResults{id, err}
        return e.mock
}</span>

// Times sets number of times UserService.CreateUser should be invoked
func (mmCreateUser *mUserServiceMockCreateUser) Times(n uint64) *mUserServiceMockCreateUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreateUser.mock.t.Fatalf("Times of UserServiceMock.CreateUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreateUser.expectedInvocations, n)
        return mmCreateUser</span>
}

func (mmCreateUser *mUserServiceMockCreateUser) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmCreateUser.expectations) == 0 &amp;&amp; mmCreateUser.defaultExpectation == nil &amp;&amp; mmCreateUser.mock.funcCreateUser == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreateUser.mock.afterCreateUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreateUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CreateUser implements service.UserService
func (mmCreateUser *UserServiceMock) CreateUser(ctx context.Context, user *model.CreateUserRequest) (id int64, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmCreateUser.beforeCreateUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreateUser.afterCreateUserCounter, 1)

        if mmCreateUser.inspectFuncCreateUser != nil </span><span class="cov0" title="0">{
                mmCreateUser.inspectFuncCreateUser(ctx, user)
        }</span>

        <span class="cov8" title="1">mm_params := UserServiceMockCreateUserParams{ctx, user}

        // Record call args
        mmCreateUser.CreateUserMock.mutex.Lock()
        mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &amp;mm_params)
        mmCreateUser.CreateUserMock.mutex.Unlock()

        for _, e := range mmCreateUser.CreateUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.id, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmCreateUser.CreateUserMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
                mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
                mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

                mm_got := UserServiceMockCreateUserParams{ctx, user}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.user != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.user, mm_got.user) </span><span class="cov0" title="0">{
                                mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreateUser.t.Errorf("UserServiceMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreateUser.t.Fatal("No results are set for the UserServiceMock.CreateUser")
                }</span>
                <span class="cov8" title="1">return (*mm_results).id, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreateUser.funcCreateUser != nil </span><span class="cov0" title="0">{
                return mmCreateUser.funcCreateUser(ctx, user)
        }</span>
        <span class="cov0" title="0">mmCreateUser.t.Fatalf("Unexpected call to UserServiceMock.CreateUser. %v %v", ctx, user)
        return</span>
}

// CreateUserAfterCounter returns a count of finished UserServiceMock.CreateUser invocations
func (mmCreateUser *UserServiceMock) CreateUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateUser.afterCreateUserCounter)
}</span>

// CreateUserBeforeCounter returns a count of UserServiceMock.CreateUser invocations
func (mmCreateUser *UserServiceMock) CreateUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateUser.beforeCreateUserCounter)
}</span>

// Calls returns a list of arguments used in each call to UserServiceMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserServiceMockCreateUser) Calls() []*UserServiceMockCreateUserParams <span class="cov0" title="0">{
        mmCreateUser.mutex.RLock()

        argCopy := make([]*UserServiceMockCreateUserParams, len(mmCreateUser.callArgs))
        copy(argCopy, mmCreateUser.callArgs)

        mmCreateUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockCreateUserDone() bool <span class="cov8" title="1">{
        if m.CreateUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.CreateUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.CreateUserMock.invocationsDone()</span>
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockCreateUserInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserServiceMock.CreateUser with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateUserCounter := mm_atomic.LoadUint64(&amp;m.afterCreateUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateUserMock.defaultExpectation != nil &amp;&amp; afterCreateUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to UserServiceMock.CreateUser")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserServiceMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreateUser != nil &amp;&amp; afterCreateUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to UserServiceMock.CreateUser")
        }</span>

        <span class="cov0" title="0">if !m.CreateUserMock.invocationsDone() &amp;&amp; afterCreateUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserServiceMock.CreateUser but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateUserMock.expectedInvocations), afterCreateUserCounter)
        }</span>
}

type mUserServiceMockDeleteUser struct {
        optional           bool
        mock               *UserServiceMock
        defaultExpectation *UserServiceMockDeleteUserExpectation
        expectations       []*UserServiceMockDeleteUserExpectation

        callArgs []*UserServiceMockDeleteUserParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// UserServiceMockDeleteUserExpectation specifies expectation struct of the UserService.DeleteUser
type UserServiceMockDeleteUserExpectation struct {
        mock      *UserServiceMock
        params    *UserServiceMockDeleteUserParams
        paramPtrs *UserServiceMockDeleteUserParamPtrs
        results   *UserServiceMockDeleteUserResults
        Counter   uint64
}

// UserServiceMockDeleteUserParams contains parameters of the UserService.DeleteUser
type UserServiceMockDeleteUserParams struct {
        ctx context.Context
        id  int64
}

// UserServiceMockDeleteUserParamPtrs contains pointers to parameters of the UserService.DeleteUser
type UserServiceMockDeleteUserParamPtrs struct {
        ctx *context.Context
        id  *int64
}

// UserServiceMockDeleteUserResults contains results of the UserService.DeleteUser
type UserServiceMockDeleteUserResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserServiceMockDeleteUser) Optional() *mUserServiceMockDeleteUser <span class="cov0" title="0">{
        mmDeleteUser.optional = true
        return mmDeleteUser
}</span>

// Expect sets up expected params for UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) Expect(ctx context.Context, id int64) *mUserServiceMockDeleteUser <span class="cov8" title="1">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmDeleteUser.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmDeleteUser.defaultExpectation = &amp;UserServiceMockDeleteUserExpectation{}
        }</span>

        <span class="cov8" title="1">if mmDeleteUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmDeleteUser.defaultExpectation.params = &amp;UserServiceMockDeleteUserParams{ctx, id}
        for _, e := range mmDeleteUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmDeleteUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockDeleteUser <span class="cov0" title="0">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation = &amp;UserServiceMockDeleteUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation.paramPtrs = &amp;UserServiceMockDeleteUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteUser.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmDeleteUser</span>
}

// ExpectIdParam2 sets up expected param id for UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) ExpectIdParam2(id int64) *mUserServiceMockDeleteUser <span class="cov0" title="0">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation = &amp;UserServiceMockDeleteUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation.paramPtrs = &amp;UserServiceMockDeleteUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteUser.defaultExpectation.paramPtrs.id = &amp;id

        return mmDeleteUser</span>
}

// Inspect accepts an inspector function that has same arguments as the UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mUserServiceMockDeleteUser <span class="cov0" title="0">{
        if mmDeleteUser.mock.inspectFuncDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.DeleteUser")
        }</span>

        <span class="cov0" title="0">mmDeleteUser.mock.inspectFuncDeleteUser = f

        return mmDeleteUser</span>
}

// Return sets up results that will be returned by UserService.DeleteUser
func (mmDeleteUser *mUserServiceMockDeleteUser) Return(err error) *UserServiceMock <span class="cov8" title="1">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmDeleteUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteUser.defaultExpectation = &amp;UserServiceMockDeleteUserExpectation{mock: mmDeleteUser.mock}
        }</span>
        <span class="cov8" title="1">mmDeleteUser.defaultExpectation.results = &amp;UserServiceMockDeleteUserResults{err}
        return mmDeleteUser.mock</span>
}

// Set uses given function f to mock the UserService.DeleteUser method
func (mmDeleteUser *mUserServiceMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *UserServiceMock <span class="cov0" title="0">{
        if mmDeleteUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserService.DeleteUser method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserService.DeleteUser method")
        }</span>

        <span class="cov0" title="0">mmDeleteUser.mock.funcDeleteUser = f
        return mmDeleteUser.mock</span>
}

// When sets expectation for the UserService.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserServiceMockDeleteUser) When(ctx context.Context, id int64) *UserServiceMockDeleteUserExpectation <span class="cov0" title="0">{
        if mmDeleteUser.mock.funcDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("UserServiceMock.DeleteUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserServiceMockDeleteUserExpectation{
                mock:   mmDeleteUser.mock,
                params: &amp;UserServiceMockDeleteUserParams{ctx, id},
        }
        mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
        return expectation</span>
}

// Then sets up UserService.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockDeleteUserExpectation) Then(err error) *UserServiceMock <span class="cov0" title="0">{
        e.results = &amp;UserServiceMockDeleteUserResults{err}
        return e.mock
}</span>

// Times sets number of times UserService.DeleteUser should be invoked
func (mmDeleteUser *mUserServiceMockDeleteUser) Times(n uint64) *mUserServiceMockDeleteUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteUser.mock.t.Fatalf("Times of UserServiceMock.DeleteUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteUser.expectedInvocations, n)
        return mmDeleteUser</span>
}

func (mmDeleteUser *mUserServiceMockDeleteUser) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmDeleteUser.expectations) == 0 &amp;&amp; mmDeleteUser.defaultExpectation == nil &amp;&amp; mmDeleteUser.mock.funcDeleteUser == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteUser.mock.afterDeleteUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteUser implements service.UserService
func (mmDeleteUser *UserServiceMock) DeleteUser(ctx context.Context, id int64) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmDeleteUser.beforeDeleteUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteUser.afterDeleteUserCounter, 1)

        if mmDeleteUser.inspectFuncDeleteUser != nil </span><span class="cov0" title="0">{
                mmDeleteUser.inspectFuncDeleteUser(ctx, id)
        }</span>

        <span class="cov8" title="1">mm_params := UserServiceMockDeleteUserParams{ctx, id}

        // Record call args
        mmDeleteUser.DeleteUserMock.mutex.Lock()
        mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &amp;mm_params)
        mmDeleteUser.DeleteUserMock.mutex.Unlock()

        for _, e := range mmDeleteUser.DeleteUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmDeleteUser.DeleteUserMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

                mm_got := UserServiceMockDeleteUserParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDeleteUser.t.Errorf("UserServiceMock.DeleteUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDeleteUser.t.Errorf("UserServiceMock.DeleteUser got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteUser.t.Errorf("UserServiceMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDeleteUser.t.Fatal("No results are set for the UserServiceMock.DeleteUser")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDeleteUser.funcDeleteUser != nil </span><span class="cov0" title="0">{
                return mmDeleteUser.funcDeleteUser(ctx, id)
        }</span>
        <span class="cov0" title="0">mmDeleteUser.t.Fatalf("Unexpected call to UserServiceMock.DeleteUser. %v %v", ctx, id)
        return</span>
}

// DeleteUserAfterCounter returns a count of finished UserServiceMock.DeleteUser invocations
func (mmDeleteUser *UserServiceMock) DeleteUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteUser.afterDeleteUserCounter)
}</span>

// DeleteUserBeforeCounter returns a count of UserServiceMock.DeleteUser invocations
func (mmDeleteUser *UserServiceMock) DeleteUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteUser.beforeDeleteUserCounter)
}</span>

// Calls returns a list of arguments used in each call to UserServiceMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserServiceMockDeleteUser) Calls() []*UserServiceMockDeleteUserParams <span class="cov0" title="0">{
        mmDeleteUser.mutex.RLock()

        argCopy := make([]*UserServiceMockDeleteUserParams, len(mmDeleteUser.callArgs))
        copy(argCopy, mmDeleteUser.callArgs)

        mmDeleteUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockDeleteUserDone() bool <span class="cov8" title="1">{
        if m.DeleteUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.DeleteUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.DeleteUserMock.invocationsDone()</span>
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockDeleteUserInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserServiceMock.DeleteUser with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteUserCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteUserMock.defaultExpectation != nil &amp;&amp; afterDeleteUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to UserServiceMock.DeleteUser")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserServiceMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteUser != nil &amp;&amp; afterDeleteUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to UserServiceMock.DeleteUser")
        }</span>

        <span class="cov0" title="0">if !m.DeleteUserMock.invocationsDone() &amp;&amp; afterDeleteUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserServiceMock.DeleteUser but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteUserMock.expectedInvocations), afterDeleteUserCounter)
        }</span>
}

type mUserServiceMockGetUser struct {
        optional           bool
        mock               *UserServiceMock
        defaultExpectation *UserServiceMockGetUserExpectation
        expectations       []*UserServiceMockGetUserExpectation

        callArgs []*UserServiceMockGetUserParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// UserServiceMockGetUserExpectation specifies expectation struct of the UserService.GetUser
type UserServiceMockGetUserExpectation struct {
        mock      *UserServiceMock
        params    *UserServiceMockGetUserParams
        paramPtrs *UserServiceMockGetUserParamPtrs
        results   *UserServiceMockGetUserResults
        Counter   uint64
}

// UserServiceMockGetUserParams contains parameters of the UserService.GetUser
type UserServiceMockGetUserParams struct {
        ctx context.Context
        id  int64
}

// UserServiceMockGetUserParamPtrs contains pointers to parameters of the UserService.GetUser
type UserServiceMockGetUserParamPtrs struct {
        ctx *context.Context
        id  *int64
}

// UserServiceMockGetUserResults contains results of the UserService.GetUser
type UserServiceMockGetUserResults struct {
        up1 *model.UserInfo
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserServiceMockGetUser) Optional() *mUserServiceMockGetUser <span class="cov0" title="0">{
        mmGetUser.optional = true
        return mmGetUser
}</span>

// Expect sets up expected params for UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) Expect(ctx context.Context, id int64) *mUserServiceMockGetUser <span class="cov8" title="1">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetUser.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmGetUser.defaultExpectation = &amp;UserServiceMockGetUserExpectation{}
        }</span>

        <span class="cov8" title="1">if mmGetUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmGetUser.defaultExpectation.params = &amp;UserServiceMockGetUserParams{ctx, id}
        for _, e := range mmGetUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmGetUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockGetUser <span class="cov0" title="0">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation = &amp;UserServiceMockGetUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation.paramPtrs = &amp;UserServiceMockGetUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetUser.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmGetUser</span>
}

// ExpectIdParam2 sets up expected param id for UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) ExpectIdParam2(id int64) *mUserServiceMockGetUser <span class="cov0" title="0">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation = &amp;UserServiceMockGetUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGetUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation.paramPtrs = &amp;UserServiceMockGetUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGetUser.defaultExpectation.paramPtrs.id = &amp;id

        return mmGetUser</span>
}

// Inspect accepts an inspector function that has same arguments as the UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) Inspect(f func(ctx context.Context, id int64)) *mUserServiceMockGetUser <span class="cov0" title="0">{
        if mmGetUser.mock.inspectFuncGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.GetUser")
        }</span>

        <span class="cov0" title="0">mmGetUser.mock.inspectFuncGetUser = f

        return mmGetUser</span>
}

// Return sets up results that will be returned by UserService.GetUser
func (mmGetUser *mUserServiceMockGetUser) Return(up1 *model.UserInfo, err error) *UserServiceMock <span class="cov8" title="1">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmGetUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGetUser.defaultExpectation = &amp;UserServiceMockGetUserExpectation{mock: mmGetUser.mock}
        }</span>
        <span class="cov8" title="1">mmGetUser.defaultExpectation.results = &amp;UserServiceMockGetUserResults{up1, err}
        return mmGetUser.mock</span>
}

// Set uses given function f to mock the UserService.GetUser method
func (mmGetUser *mUserServiceMockGetUser) Set(f func(ctx context.Context, id int64) (up1 *model.UserInfo, err error)) *UserServiceMock <span class="cov0" title="0">{
        if mmGetUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("Default expectation is already set for the UserService.GetUser method")
        }</span>

        <span class="cov0" title="0">if len(mmGetUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("Some expectations are already set for the UserService.GetUser method")
        }</span>

        <span class="cov0" title="0">mmGetUser.mock.funcGetUser = f
        return mmGetUser.mock</span>
}

// When sets expectation for the UserService.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserServiceMockGetUser) When(ctx context.Context, id int64) *UserServiceMockGetUserExpectation <span class="cov0" title="0">{
        if mmGetUser.mock.funcGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("UserServiceMock.GetUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserServiceMockGetUserExpectation{
                mock:   mmGetUser.mock,
                params: &amp;UserServiceMockGetUserParams{ctx, id},
        }
        mmGetUser.expectations = append(mmGetUser.expectations, expectation)
        return expectation</span>
}

// Then sets up UserService.GetUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockGetUserExpectation) Then(up1 *model.UserInfo, err error) *UserServiceMock <span class="cov0" title="0">{
        e.results = &amp;UserServiceMockGetUserResults{up1, err}
        return e.mock
}</span>

// Times sets number of times UserService.GetUser should be invoked
func (mmGetUser *mUserServiceMockGetUser) Times(n uint64) *mUserServiceMockGetUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGetUser.mock.t.Fatalf("Times of UserServiceMock.GetUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGetUser.expectedInvocations, n)
        return mmGetUser</span>
}

func (mmGetUser *mUserServiceMockGetUser) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmGetUser.expectations) == 0 &amp;&amp; mmGetUser.defaultExpectation == nil &amp;&amp; mmGetUser.mock.funcGetUser == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmGetUser.mock.afterGetUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGetUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// GetUser implements service.UserService
func (mmGetUser *UserServiceMock) GetUser(ctx context.Context, id int64) (up1 *model.UserInfo, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmGetUser.beforeGetUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGetUser.afterGetUserCounter, 1)

        if mmGetUser.inspectFuncGetUser != nil </span><span class="cov0" title="0">{
                mmGetUser.inspectFuncGetUser(ctx, id)
        }</span>

        <span class="cov8" title="1">mm_params := UserServiceMockGetUserParams{ctx, id}

        // Record call args
        mmGetUser.GetUserMock.mutex.Lock()
        mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &amp;mm_params)
        mmGetUser.GetUserMock.mutex.Unlock()

        for _, e := range mmGetUser.GetUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.up1, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmGetUser.GetUserMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
                mm_want := mmGetUser.GetUserMock.defaultExpectation.params
                mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

                mm_got := UserServiceMockGetUserParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGetUser.t.Errorf("UserServiceMock.GetUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmGetUser.t.Errorf("UserServiceMock.GetUser got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGetUser.t.Errorf("UserServiceMock.GetUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmGetUser.GetUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGetUser.t.Fatal("No results are set for the UserServiceMock.GetUser")
                }</span>
                <span class="cov8" title="1">return (*mm_results).up1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGetUser.funcGetUser != nil </span><span class="cov0" title="0">{
                return mmGetUser.funcGetUser(ctx, id)
        }</span>
        <span class="cov0" title="0">mmGetUser.t.Fatalf("Unexpected call to UserServiceMock.GetUser. %v %v", ctx, id)
        return</span>
}

// GetUserAfterCounter returns a count of finished UserServiceMock.GetUser invocations
func (mmGetUser *UserServiceMock) GetUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetUser.afterGetUserCounter)
}</span>

// GetUserBeforeCounter returns a count of UserServiceMock.GetUser invocations
func (mmGetUser *UserServiceMock) GetUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGetUser.beforeGetUserCounter)
}</span>

// Calls returns a list of arguments used in each call to UserServiceMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserServiceMockGetUser) Calls() []*UserServiceMockGetUserParams <span class="cov0" title="0">{
        mmGetUser.mutex.RLock()

        argCopy := make([]*UserServiceMockGetUserParams, len(mmGetUser.callArgs))
        copy(argCopy, mmGetUser.callArgs)

        mmGetUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockGetUserDone() bool <span class="cov8" title="1">{
        if m.GetUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.GetUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.GetUserMock.invocationsDone()</span>
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockGetUserInspect() <span class="cov0" title="0">{
        for _, e := range m.GetUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserServiceMock.GetUser with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetUserCounter := mm_atomic.LoadUint64(&amp;m.afterGetUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetUserMock.defaultExpectation != nil &amp;&amp; afterGetUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to UserServiceMock.GetUser")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserServiceMock.GetUser with params: %#v", *m.GetUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGetUser != nil &amp;&amp; afterGetUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to UserServiceMock.GetUser")
        }</span>

        <span class="cov0" title="0">if !m.GetUserMock.invocationsDone() &amp;&amp; afterGetUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserServiceMock.GetUser but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetUserMock.expectedInvocations), afterGetUserCounter)
        }</span>
}

type mUserServiceMockUpdateUser struct {
        optional           bool
        mock               *UserServiceMock
        defaultExpectation *UserServiceMockUpdateUserExpectation
        expectations       []*UserServiceMockUpdateUserExpectation

        callArgs []*UserServiceMockUpdateUserParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// UserServiceMockUpdateUserExpectation specifies expectation struct of the UserService.UpdateUser
type UserServiceMockUpdateUserExpectation struct {
        mock      *UserServiceMock
        params    *UserServiceMockUpdateUserParams
        paramPtrs *UserServiceMockUpdateUserParamPtrs
        results   *UserServiceMockUpdateUserResults
        Counter   uint64
}

// UserServiceMockUpdateUserParams contains parameters of the UserService.UpdateUser
type UserServiceMockUpdateUserParams struct {
        ctx  context.Context
        user *model.UpdateUserRequest
}

// UserServiceMockUpdateUserParamPtrs contains pointers to parameters of the UserService.UpdateUser
type UserServiceMockUpdateUserParamPtrs struct {
        ctx  *context.Context
        user **model.UpdateUserRequest
}

// UserServiceMockUpdateUserResults contains results of the UserService.UpdateUser
type UserServiceMockUpdateUserResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUserServiceMockUpdateUser) Optional() *mUserServiceMockUpdateUser <span class="cov0" title="0">{
        mmUpdateUser.optional = true
        return mmUpdateUser
}</span>

// Expect sets up expected params for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) Expect(ctx context.Context, user *model.UpdateUserRequest) *mUserServiceMockUpdateUser <span class="cov8" title="1">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmUpdateUser.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmUpdateUser.defaultExpectation = &amp;UserServiceMockUpdateUserExpectation{}
        }</span>

        <span class="cov8" title="1">if mmUpdateUser.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmUpdateUser.defaultExpectation.params = &amp;UserServiceMockUpdateUserParams{ctx, user}
        for _, e := range mmUpdateUser.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmUpdateUser</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUserServiceMockUpdateUser <span class="cov0" title="0">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation = &amp;UserServiceMockUpdateUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation.paramPtrs = &amp;UserServiceMockUpdateUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdateUser.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmUpdateUser</span>
}

// ExpectUserParam2 sets up expected param user for UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) ExpectUserParam2(user *model.UpdateUserRequest) *mUserServiceMockUpdateUser <span class="cov0" title="0">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation = &amp;UserServiceMockUpdateUserExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdateUser.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation.paramPtrs = &amp;UserServiceMockUpdateUserParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdateUser.defaultExpectation.paramPtrs.user = &amp;user

        return mmUpdateUser</span>
}

// Inspect accepts an inspector function that has same arguments as the UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) Inspect(f func(ctx context.Context, user *model.UpdateUserRequest)) *mUserServiceMockUpdateUser <span class="cov0" title="0">{
        if mmUpdateUser.mock.inspectFuncUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UserServiceMock.UpdateUser")
        }</span>

        <span class="cov0" title="0">mmUpdateUser.mock.inspectFuncUpdateUser = f

        return mmUpdateUser</span>
}

// Return sets up results that will be returned by UserService.UpdateUser
func (mmUpdateUser *mUserServiceMockUpdateUser) Return(err error) *UserServiceMock <span class="cov8" title="1">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmUpdateUser.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdateUser.defaultExpectation = &amp;UserServiceMockUpdateUserExpectation{mock: mmUpdateUser.mock}
        }</span>
        <span class="cov8" title="1">mmUpdateUser.defaultExpectation.results = &amp;UserServiceMockUpdateUserResults{err}
        return mmUpdateUser.mock</span>
}

// Set uses given function f to mock the UserService.UpdateUser method
func (mmUpdateUser *mUserServiceMockUpdateUser) Set(f func(ctx context.Context, user *model.UpdateUserRequest) (err error)) *UserServiceMock <span class="cov0" title="0">{
        if mmUpdateUser.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the UserService.UpdateUser method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdateUser.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the UserService.UpdateUser method")
        }</span>

        <span class="cov0" title="0">mmUpdateUser.mock.funcUpdateUser = f
        return mmUpdateUser.mock</span>
}

// When sets expectation for the UserService.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUserServiceMockUpdateUser) When(ctx context.Context, user *model.UpdateUserRequest) *UserServiceMockUpdateUserExpectation <span class="cov0" title="0">{
        if mmUpdateUser.mock.funcUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("UserServiceMock.UpdateUser mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserServiceMockUpdateUserExpectation{
                mock:   mmUpdateUser.mock,
                params: &amp;UserServiceMockUpdateUserParams{ctx, user},
        }
        mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
        return expectation</span>
}

// Then sets up UserService.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UserServiceMockUpdateUserExpectation) Then(err error) *UserServiceMock <span class="cov0" title="0">{
        e.results = &amp;UserServiceMockUpdateUserResults{err}
        return e.mock
}</span>

// Times sets number of times UserService.UpdateUser should be invoked
func (mmUpdateUser *mUserServiceMockUpdateUser) Times(n uint64) *mUserServiceMockUpdateUser <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdateUser.mock.t.Fatalf("Times of UserServiceMock.UpdateUser mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdateUser.expectedInvocations, n)
        return mmUpdateUser</span>
}

func (mmUpdateUser *mUserServiceMockUpdateUser) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmUpdateUser.expectations) == 0 &amp;&amp; mmUpdateUser.defaultExpectation == nil &amp;&amp; mmUpdateUser.mock.funcUpdateUser == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdateUser.mock.afterUpdateUserCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdateUser.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// UpdateUser implements service.UserService
func (mmUpdateUser *UserServiceMock) UpdateUser(ctx context.Context, user *model.UpdateUserRequest) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmUpdateUser.beforeUpdateUserCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdateUser.afterUpdateUserCounter, 1)

        if mmUpdateUser.inspectFuncUpdateUser != nil </span><span class="cov0" title="0">{
                mmUpdateUser.inspectFuncUpdateUser(ctx, user)
        }</span>

        <span class="cov8" title="1">mm_params := UserServiceMockUpdateUserParams{ctx, user}

        // Record call args
        mmUpdateUser.UpdateUserMock.mutex.Lock()
        mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &amp;mm_params)
        mmUpdateUser.UpdateUserMock.mutex.Unlock()

        for _, e := range mmUpdateUser.UpdateUserMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmUpdateUser.UpdateUserMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
                mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

                mm_got := UserServiceMockUpdateUserParams{ctx, user}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.user != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.user, mm_got.user) </span><span class="cov0" title="0">{
                                mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdateUser.t.Errorf("UserServiceMock.UpdateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdateUser.t.Fatal("No results are set for the UserServiceMock.UpdateUser")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdateUser.funcUpdateUser != nil </span><span class="cov0" title="0">{
                return mmUpdateUser.funcUpdateUser(ctx, user)
        }</span>
        <span class="cov0" title="0">mmUpdateUser.t.Fatalf("Unexpected call to UserServiceMock.UpdateUser. %v %v", ctx, user)
        return</span>
}

// UpdateUserAfterCounter returns a count of finished UserServiceMock.UpdateUser invocations
func (mmUpdateUser *UserServiceMock) UpdateUserAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdateUser.afterUpdateUserCounter)
}</span>

// UpdateUserBeforeCounter returns a count of UserServiceMock.UpdateUser invocations
func (mmUpdateUser *UserServiceMock) UpdateUserBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdateUser.beforeUpdateUserCounter)
}</span>

// Calls returns a list of arguments used in each call to UserServiceMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUserServiceMockUpdateUser) Calls() []*UserServiceMockUpdateUserParams <span class="cov0" title="0">{
        mmUpdateUser.mutex.RLock()

        argCopy := make([]*UserServiceMockUpdateUserParams, len(mmUpdateUser.callArgs))
        copy(argCopy, mmUpdateUser.callArgs)

        mmUpdateUser.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UserServiceMock) MinimockUpdateUserDone() bool <span class="cov8" title="1">{
        if m.UpdateUserMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.UpdateUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.UpdateUserMock.invocationsDone()</span>
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UserServiceMock) MinimockUpdateUserInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateUserMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserServiceMock.UpdateUser with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateUserCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateUserCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateUserMock.defaultExpectation != nil &amp;&amp; afterUpdateUserCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateUserMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to UserServiceMock.UpdateUser")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserServiceMock.UpdateUser with params: %#v", *m.UpdateUserMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdateUser != nil &amp;&amp; afterUpdateUserCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to UserServiceMock.UpdateUser")
        }</span>

        <span class="cov0" title="0">if !m.UpdateUserMock.invocationsDone() &amp;&amp; afterUpdateUserCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserServiceMock.UpdateUser but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateUserMock.expectedInvocations), afterUpdateUserCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserServiceMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateUserInspect()

                        m.MinimockDeleteUserInspect()

                        m.MinimockGetUserInspect()

                        m.MinimockUpdateUserInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserServiceMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *UserServiceMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateUserDone() &amp;&amp;
                m.MinimockDeleteUserDone() &amp;&amp;
                m.MinimockGetUserDone() &amp;&amp;
                m.MinimockUpdateUserDone()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package user

import (
        "context"
        "log"

        "github.com/ArtEmerged/o_auth-server/internal/model"
)

// CreateUser creates a new user and returns the user ID.
func (s *userService) CreateUser(ctx context.Context, in *model.CreateUserRequest) (int64, error) <span class="cov0" title="0">{
        if err := in.Validate(); err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">in.PasswordHash = s.hashSha256(in.Password)

        userInfo, err := s.repo.CreateUser(ctx, in)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">err = s.cache.Set(ctx, model.UserCacheKey(userInfo.ID), userInfo, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WARN: failed to set user in cache: %s\n", err.Error())
        }</span>

        <span class="cov0" title="0">return userInfo.ID, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package user

import (
        "context"
        "log"

        "github.com/ArtEmerged/o_auth-server/internal/model"
)

// DeleteUser deletes a user by ID.
func (s *userService) DeleteUser(ctx context.Context, id int64) error <span class="cov0" title="0">{
        err := s.repo.DeleteUser(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.cache.Del(ctx, model.UserCacheKey(id))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WARN: failed to delete user in cache: %s\n", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package user

import (
        "context"
        "log"

        "github.com/ArtEmerged/o_auth-server/internal/model"
)

// GetUser retrieves a user from the repository by ID and returns the user information.
func (s *userService) GetUser(ctx context.Context, id int64) (*model.UserInfo, error) <span class="cov0" title="0">{
        userInfo := new(model.UserInfo)

        err := s.cache.Get(ctx, model.UserCacheKey(id), userInfo)
        if err == nil </span><span class="cov0" title="0">{
                return userInfo, nil
        }</span>

        <span class="cov0" title="0">log.Printf("WARN: failed to get user in cache: %s\n", err.Error())

        userInfo, err = s.repo.GetUser(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = s.cache.Set(ctx, model.UserCacheKey(userInfo.ID), userInfo, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WARN: failed to set user in cache: %s\n", err.Error())
        }</span>

        <span class="cov0" title="0">return userInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package user

import (
        "crypto/sha256"
        "fmt"
)

func (s *userService) hashSha256(in string) string <span class="cov8" title="1">{
        h := sha256.New()

        h.Write(s.salt)
        h.Write([]byte(in))

        return fmt.Sprintf("%x", h.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package user

import (
        "github.com/ArtEmerged/library/client/cache"
        "github.com/ArtEmerged/library/client/db"

        "github.com/ArtEmerged/o_auth-server/internal/repository"
        "github.com/ArtEmerged/o_auth-server/internal/service"
)

type userService struct {
        repo      repository.UserRepo
        txManager db.TxManager
        cache     cache.Cache

        salt []byte
}

// New creates a new user service.
func New(repo repository.UserRepo, txManager db.TxManager, cache cache.Cache, salt string) service.UserService <span class="cov0" title="0">{
        return &amp;userService{
                repo:      repo,
                txManager: txManager,
                cache:     cache,
                salt:      []byte(salt)}
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package user

import (
        "context"
        "errors"
        "log"

        "github.com/ArtEmerged/o_auth-server/internal/model"
)

// UpdateUser updates an existing user in the repository.
func (s *userService) UpdateUser(ctx context.Context, in *model.UpdateUserRequest) error <span class="cov0" title="0">{
        err := in.Validate()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, model.ErrWithoutChanges) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">user, err := s.repo.GetUser(ctx, in.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if in.Name == "" </span><span class="cov0" title="0">{
                in.Name = user.Name
        }</span>

        <span class="cov0" title="0">if in.Role == model.RoleUnknown </span><span class="cov0" title="0">{
                in.Role = user.Role
        }</span>

        <span class="cov0" title="0">updatedAt, err := s.repo.UpdateUser(ctx, in)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">userInfo := &amp;model.UserInfo{
                ID:        in.ID,
                Name:      in.Name,
                Email:     user.Email,
                Role:      in.Role,
                CreatedAt: user.CreatedAt,
                UpdatedAt: &amp;updatedAt,
        }

        err = s.cache.Set(ctx, model.UserCacheKey(in.ID), userInfo, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WARN: failed to set user in cache: %s\n", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        v4.24.3
// source: auth.proto

package auth_v1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Role int32

const (
        Role_UNKNOWN Role = 0
        Role_USER    Role = 1
        Role_ADMIN   Role = 2
)

// Enum value maps for Role.
var (
        Role_name = map[int32]string{
                0: "UNKNOWN",
                1: "USER",
                2: "ADMIN",
        }
        Role_value = map[string]int32{
                "UNKNOWN": 0,
                "USER":    1,
                "ADMIN":   2,
        }
)

func (x Role) Enum() *Role <span class="cov0" title="0">{
        p := new(Role)
        *p = x
        return p
}</span>

func (x Role) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Role) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_auth_proto_enumTypes[0].Descriptor()
}</span>

func (Role) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_auth_proto_enumTypes[0]
}</span>

func (x Role) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Role.Descriptor instead.
func (Role) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{0}
}</span>

type UserInfo struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id    int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        Role  Role   `protobuf:"varint,4,opt,name=role,proto3,enum=auth_v1.Role" json:"role,omitempty"`
        // Types that are assignable to Timestamp:
        //
        //        *UserInfo_CreatedAt
        //        *UserInfo_UpdatedAt
        Timestamp isUserInfo_Timestamp `protobuf_oneof:"timestamp"`
}

func (x *UserInfo) Reset() <span class="cov0" title="0">{
        *x = UserInfo{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserInfo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserInfo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserInfo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserInfo.ProtoReflect.Descriptor instead.
func (*UserInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{0}
}</span>

func (x *UserInfo) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserInfo) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserInfo) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserInfo) GetRole() Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return Role_UNKNOWN</span>
}

func (m *UserInfo) GetTimestamp() isUserInfo_Timestamp <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UserInfo) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x, ok := x.GetTimestamp().(*UserInfo_CreatedAt); ok </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UserInfo) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x, ok := x.GetTimestamp().(*UserInfo_UpdatedAt); ok </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isUserInfo_Timestamp interface {
        isUserInfo_Timestamp()
}

type UserInfo_CreatedAt struct {
        CreatedAt *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3,oneof"`
}

type UserInfo_UpdatedAt struct {
        UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3,oneof"`
}

func (*UserInfo_CreatedAt) isUserInfo_Timestamp() {<span class="cov0" title="0">}</span>

func (*UserInfo_UpdatedAt) isUserInfo_Timestamp() {<span class="cov0" title="0">}</span>

type CreateUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name            string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Email           string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        Password        string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
        PasswordConfirm string `protobuf:"bytes,4,opt,name=password_confirm,json=passwordConfirm,proto3" json:"password_confirm,omitempty"`
        Role            Role   `protobuf:"varint,5,opt,name=role,proto3,enum=auth_v1.Role" json:"role,omitempty"`
}

func (x *CreateUserRequest) Reset() <span class="cov0" title="0">{
        *x = CreateUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateUserRequest.ProtoReflect.Descriptor instead.
func (*CreateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateUserRequest) GetName() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetEmail() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetPassword() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetPasswordConfirm() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.PasswordConfirm
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetRole() Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return Role_UNKNOWN</span>
}

type CreateUserResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *CreateUserResponse) Reset() <span class="cov0" title="0">{
        *x = CreateUserResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateUserResponse.ProtoReflect.Descriptor instead.
func (*CreateUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{2}
}</span>

func (x *CreateUserResponse) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRequest.ProtoReflect.Descriptor instead.
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetUserRequest) GetId() int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserInfo *UserInfo `protobuf:"bytes,1,opt,name=user_info,json=userInfo,proto3" json:"user_info,omitempty"`
}

func (x *GetUserResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserResponse.ProtoReflect.Descriptor instead.
func (*GetUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{4}
}</span>

func (x *GetUserResponse) GetUserInfo() *UserInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserInfo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id   int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Name *string `protobuf:"bytes,2,opt,name=name,proto3,oneof" json:"name,omitempty"`
        Role Role    `protobuf:"varint,4,opt,name=role,proto3,enum=auth_v1.Role" json:"role,omitempty"`
}

func (x *UpdateUserRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserRequest.ProtoReflect.Descriptor instead.
func (*UpdateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{5}
}</span>

func (x *UpdateUserRequest) GetId() int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdateUserRequest) GetName() string <span class="cov8" title="1">{
        if x != nil &amp;&amp; x.Name != nil </span><span class="cov8" title="1">{
                return *x.Name
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func (x *UpdateUserRequest) GetRole() Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return Role_UNKNOWN</span>
}

type DeleteUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *DeleteUserRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteUserRequest.ProtoReflect.Descriptor instead.
func (*DeleteUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{6}
}</span>

func (x *DeleteUserRequest) GetId() int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_auth_proto protoreflect.FileDescriptor

var file_auth_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x61, 0x75,
        0x74, 0x68, 0x5f, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x22, 0xee, 0x01, 0x0a, 0x08, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64,
        0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x21, 0x0a, 0x04, 0x72, 0x6f,
        0x6c, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x5f,
        0x76, 0x31, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x12, 0x3b, 0x0a,
        0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x48, 0x00, 0x52,
        0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x3b, 0x0a, 0x0a, 0x75, 0x70,
        0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x48, 0x00, 0x52, 0x09, 0x75, 0x70,
        0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x42, 0x0b, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x22, 0xa7, 0x01, 0x0a, 0x11, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55,
        0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14,
        0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65,
        0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64,
        0x12, 0x29, 0x0a, 0x10, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x63, 0x6f, 0x6e,
        0x66, 0x69, 0x72, 0x6d, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x70, 0x61, 0x73, 0x73,
        0x77, 0x6f, 0x72, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x12, 0x21, 0x0a, 0x04, 0x72,
        0x6f, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x5f, 0x76, 0x31, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x22, 0x24,
        0x0a, 0x12, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03,
        0x52, 0x02, 0x69, 0x64, 0x22, 0x20, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x22, 0x41, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65,
        0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2e, 0x0a, 0x09, 0x75, 0x73, 0x65,
        0x72, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x61,
        0x75, 0x74, 0x68, 0x5f, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52,
        0x08, 0x75, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x68, 0x0a, 0x11, 0x55, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e,
        0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x17,
        0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x88, 0x01, 0x01, 0x12, 0x21, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x76, 0x31, 0x2e,
        0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x42, 0x07, 0x0a, 0x05, 0x5f, 0x6e,
        0x61, 0x6d, 0x65, 0x22, 0x23, 0x0a, 0x11, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x73, 0x65,
        0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x2a, 0x28, 0x0a, 0x04, 0x52, 0x6f, 0x6c, 0x65,
        0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x08, 0x0a,
        0x04, 0x55, 0x53, 0x45, 0x52, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x41, 0x44, 0x4d, 0x49, 0x4e,
        0x10, 0x02, 0x32, 0x91, 0x02, 0x0a, 0x06, 0x55, 0x73, 0x65, 0x72, 0x56, 0x31, 0x12, 0x45, 0x0a,
        0x0a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1a, 0x2e, 0x61, 0x75,
        0x74, 0x68, 0x5f, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x76,
        0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3c, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x12,
        0x17, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65,
        0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x5f,
        0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x40, 0x0a, 0x0a, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72,
        0x12, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74,
        0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45,
        0x6d, 0x70, 0x74, 0x79, 0x12, 0x40, 0x0a, 0x0a, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x73,
        0x65, 0x72, 0x12, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c,
        0x65, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x42, 0x32, 0x5a, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62,
        0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x41, 0x72, 0x74, 0x45, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x64, 0x2f,
        0x6f, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x61, 0x75, 0x74, 0x68, 0x5f,
        0x76, 0x31, 0x3b, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x33,
}

var (
        file_auth_proto_rawDescOnce sync.Once
        file_auth_proto_rawDescData = file_auth_proto_rawDesc
)

func file_auth_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_auth_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_auth_proto_rawDescData = protoimpl.X.CompressGZIP(file_auth_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_auth_proto_rawDescData</span>
}

var file_auth_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_auth_proto_goTypes = []any{
        (Role)(0),                     // 0: auth_v1.Role
        (*UserInfo)(nil),              // 1: auth_v1.UserInfo
        (*CreateUserRequest)(nil),     // 2: auth_v1.CreateUserRequest
        (*CreateUserResponse)(nil),    // 3: auth_v1.CreateUserResponse
        (*GetUserRequest)(nil),        // 4: auth_v1.GetUserRequest
        (*GetUserResponse)(nil),       // 5: auth_v1.GetUserResponse
        (*UpdateUserRequest)(nil),     // 6: auth_v1.UpdateUserRequest
        (*DeleteUserRequest)(nil),     // 7: auth_v1.DeleteUserRequest
        (*timestamppb.Timestamp)(nil), // 8: google.protobuf.Timestamp
        (*emptypb.Empty)(nil),         // 9: google.protobuf.Empty
}
var file_auth_proto_depIdxs = []int32{
        0,  // 0: auth_v1.UserInfo.role:type_name -&gt; auth_v1.Role
        8,  // 1: auth_v1.UserInfo.created_at:type_name -&gt; google.protobuf.Timestamp
        8,  // 2: auth_v1.UserInfo.updated_at:type_name -&gt; google.protobuf.Timestamp
        0,  // 3: auth_v1.CreateUserRequest.role:type_name -&gt; auth_v1.Role
        1,  // 4: auth_v1.GetUserResponse.user_info:type_name -&gt; auth_v1.UserInfo
        0,  // 5: auth_v1.UpdateUserRequest.role:type_name -&gt; auth_v1.Role
        2,  // 6: auth_v1.UserV1.CreateUser:input_type -&gt; auth_v1.CreateUserRequest
        4,  // 7: auth_v1.UserV1.GetUser:input_type -&gt; auth_v1.GetUserRequest
        6,  // 8: auth_v1.UserV1.UpdateUser:input_type -&gt; auth_v1.UpdateUserRequest
        7,  // 9: auth_v1.UserV1.DeleteUser:input_type -&gt; auth_v1.DeleteUserRequest
        3,  // 10: auth_v1.UserV1.CreateUser:output_type -&gt; auth_v1.CreateUserResponse
        5,  // 11: auth_v1.UserV1.GetUser:output_type -&gt; auth_v1.GetUserResponse
        9,  // 12: auth_v1.UserV1.UpdateUser:output_type -&gt; google.protobuf.Empty
        9,  // 13: auth_v1.UserV1.DeleteUser:output_type -&gt; google.protobuf.Empty
        10, // [10:14] is the sub-list for method output_type
        6,  // [6:10] is the sub-list for method input_type
        6,  // [6:6] is the sub-list for extension type_name
        6,  // [6:6] is the sub-list for extension extendee
        0,  // [0:6] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_auth_proto_init() }</span>
func file_auth_proto_init() <span class="cov8" title="1">{
        if File_auth_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_auth_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*UserInfo); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[1].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CreateUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[2].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CreateUserResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[3].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[4].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetUserResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[5].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[6].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_auth_proto_msgTypes[0].OneofWrappers = []any{
                (*UserInfo_CreatedAt)(nil),
                (*UserInfo_UpdatedAt)(nil),
        }
        file_auth_proto_msgTypes[5].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_auth_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   7,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_auth_proto_goTypes,
                DependencyIndexes: file_auth_proto_depIdxs,
                EnumInfos:         file_auth_proto_enumTypes,
                MessageInfos:      file_auth_proto_msgTypes,
        }.Build()
        File_auth_proto = out.File
        file_auth_proto_rawDesc = nil
        file_auth_proto_goTypes = nil
        file_auth_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v4.24.3
// source: auth.proto

package auth_v1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        UserV1_CreateUser_FullMethodName = "/auth_v1.UserV1/CreateUser"
        UserV1_GetUser_FullMethodName    = "/auth_v1.UserV1/GetUser"
        UserV1_UpdateUser_FullMethodName = "/auth_v1.UserV1/UpdateUser"
        UserV1_DeleteUser_FullMethodName = "/auth_v1.UserV1/DeleteUser"
)

// UserV1Client is the client API for UserV1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserV1Client interface {
        CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
        GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
        UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userV1Client struct {
        cc grpc.ClientConnInterface
}

func NewUserV1Client(cc grpc.ClientConnInterface) UserV1Client <span class="cov0" title="0">{
        return &amp;userV1Client{cc}
}</span>

func (c *userV1Client) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateUserResponse)
        err := c.cc.Invoke(ctx, UserV1_CreateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userV1Client) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserResponse)
        err := c.cc.Invoke(ctx, UserV1_GetUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userV1Client) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, UserV1_UpdateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userV1Client) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, UserV1_DeleteUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserV1Server is the server API for UserV1 service.
// All implementations must embed UnimplementedUserV1Server
// for forward compatibility
type UserV1Server interface {
        CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
        GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
        UpdateUser(context.Context, *UpdateUserRequest) (*emptypb.Empty, error)
        DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error)
        mustEmbedUnimplementedUserV1Server()
}

// UnimplementedUserV1Server must be embedded to have forward compatible implementations.
type UnimplementedUserV1Server struct {
}

func (UnimplementedUserV1Server) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}</span>
func (UnimplementedUserV1Server) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}</span>
func (UnimplementedUserV1Server) UpdateUser(context.Context, *UpdateUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}</span>
func (UnimplementedUserV1Server) DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}</span>
func (UnimplementedUserV1Server) mustEmbedUnimplementedUserV1Server() {<span class="cov0" title="0">}</span>

// UnsafeUserV1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserV1Server will
// result in compilation errors.
type UnsafeUserV1Server interface {
        mustEmbedUnimplementedUserV1Server()
}

func RegisterUserV1Server(s grpc.ServiceRegistrar, srv UserV1Server) <span class="cov0" title="0">{
        s.RegisterService(&amp;UserV1_ServiceDesc, srv)
}</span>

func _UserV1_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserV1Server).CreateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserV1_CreateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserV1Server).CreateUser(ctx, req.(*CreateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserV1_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserV1Server).GetUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserV1_GetUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserV1Server).GetUser(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserV1_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserV1Server).UpdateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserV1_UpdateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserV1Server).UpdateUser(ctx, req.(*UpdateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserV1_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserV1Server).DeleteUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserV1_DeleteUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserV1Server).DeleteUser(ctx, req.(*DeleteUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// UserV1_ServiceDesc is the grpc.ServiceDesc for UserV1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserV1_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "auth_v1.UserV1",
        HandlerType: (*UserV1Server)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateUser",
                        Handler:    _UserV1_CreateUser_Handler,
                },
                {
                        MethodName: "GetUser",
                        Handler:    _UserV1_GetUser_Handler,
                },
                {
                        MethodName: "UpdateUser",
                        Handler:    _UserV1_UpdateUser_Handler,
                },
                {
                        MethodName: "DeleteUser",
                        Handler:    _UserV1_DeleteUser_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "auth.proto",
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
